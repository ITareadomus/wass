Perfetto: se usi **Replit Object Storage**, ecco cosa dire/aggiungere a Replit (o cosa mettere tu in repo) per far funzionare autoload + salvataggio senza più l’errore `Unexpected token '<'`.

# Checklist “da passare a Replit”

1. **Dipendenza corretta**

```bash
npm i @replit/object-storage
```

2. **Node >= 18** (meglio 20). Nel replit `package.json`:

```json
"engines": { "node": ">=18" }
```

3. **Express JSON attivo** (altrimenti il body è vuoto e gli endpoint possono crashare → HTML):

```ts
app.use(express.json({ limit: "2mb" }));
```

4. **Rispondere SEMPRE JSON** (imposta il content-type, così il client non prova a parsare HTML):

```ts
app.use((req,res,next) => { res.setHeader('Content-Type','application/json; charset=utf-8'); next(); });
```

5. **Usare SOLO `@replit/object-storage`** in tutti gli endpoint di check/load/save
   Niente `@google-cloud/storage`, niente `REPLIT_OBJECT_STORAGE_BUCKET_ID`. Unifica sul bucket, es: `wass_assignments`.

6. **Controllo esistenza file senza HEAD**
   `Object Storage` di Replit non espone `HEAD`; fai `downloadAsText` e gestisci `ok/404`.

7. **Vite proxy (se usi Vite)**
   In `vite.config.ts` assicurati che le chiamate `/api/*` finiscano davvero al server Node (e non a Vite dev server che restituisce HTML):

```ts
server: { proxy: { '/api': 'http://localhost:3000' } }
```

---

# Patch pronta (3 endpoint allineati a Replit Object Storage)

> Sostituisci/aggiungi questi handler in `server/routes.ts`. Mantieni lo **stesso** `bucket` ovunque.

```ts
import { format } from "date-fns";
import { it } from "date-fns/locale";
import type { Request, Response } from "express";

type SavedAssignments = unknown; // tipizza se vuoi

// Utility: stessa costruzione chiave file ovunque
function buildKey(isoDate: string) {
  const d = new Date(isoDate);
  const day = String(d.getDate()).padStart(2, "0");
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const fullYear = String(d.getFullYear());
  const year = fullYear.slice(-2);
  const folder = `${day}-${month}-${fullYear}`;
  const filename = `assignments_${day}${month}${year}.json`;
  return { key: `${folder}/${filename}`, d };
}

const BUCKET = "wass_assignments";

// 1) CHECK: esistono assegnazioni salvate?
app.post("/api/check-saved-assignments", async (req: Request, res: Response) => {
  try {
    const { Client } = await import("@replit/object-storage");
    const client = new Client();

    const date: string = req.body?.date || format(new Date(), "yyyy-MM-dd");
    const { key, d } = buildKey(date);

    const r = await client.downloadAsText(key, { bucket: BUCKET });

    if (r.ok) {
      return res.json({
        success: true,
        found: true,
        filename: key,
        formattedDate: format(d, "dd/MM/yyyy", { locale: it })
      });
    }

    // NOT FOUND o altro (non ok)
    return res.json({ success: true, found: false });
  } catch (e: any) {
    console.error("check-saved-assignments error:", e);
    return res.status(200).json({ success: false, found: false, error: String(e?.message || e) });
  }
});

// 2) LOAD: carica il JSON salvato
app.post("/api/load-saved-assignments", async (req: Request, res: Response) => {
  try {
    const { Client } = await import("@replit/object-storage");
    const client = new Client();

    const date: string = req.body?.date || format(new Date(), "yyyy-MM-dd");
    const { key } = buildKey(date);

    const r = await client.downloadAsText(key, { bucket: BUCKET });
    if (!r.ok) {
      return res.json({ success: false, message: "Nessun file salvato per questa data." });
    }

    // r.text contiene già il JSON in stringa
    const payload = JSON.parse(r.text);
    return res.json({ success: true, data: payload as SavedAssignments, filename: key });
  } catch (e: any) {
    console.error("load-saved-assignments error:", e);
    return res.status(200).json({ success: false, error: String(e?.message || e) });
  }
});

// 3) SAVE/CONFIRM: salva il JSON
app.post("/api/confirm-assignments", async (req: Request, res: Response) => {
  try {
    const { Client } = await import("@replit/object-storage");
    const client = new Client();

    const { date, assignments } = req.body as { date: string; assignments: SavedAssignments };
    if (!date || !assignments) {
      return res.json({ success: false, error: "date e assignments sono obbligatori" });
    }

    const { key, d } = buildKey(date);
    const body = JSON.stringify(assignments);

    const r = await client.uploadText(key, body, {
      bucket: BUCKET,
      contentType: "application/json; charset=utf-8",
      cacheControl: "no-store"
    });

    if (!r.ok) {
      return res.json({ success: false, error: "Upload fallito" });
    }

    return res.json({
      success: true,
      filename: key,
      savedAt: format(d, "dd/MM/yyyy HH:mm", { locale: it })
    });
  } catch (e: any) {
    console.error("confirm-assignments error:", e);
    return res.status(200).json({ success: false, error: String(e?.message || e) });
  }
});
```

---

# Hardening lato **client** (evita per sempre l’errore `Unexpected token '<'`)

Nel punto in cui chiami `fetch('/api/check-saved-assignments')` e `fetch('/api/load-saved-assignments')`:

```ts
const r = await fetch("/api/check-saved-assignments", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ date: dateISO })
});

const ct = r.headers.get("content-type") || "";
if (!ct.includes("application/json")) {
  const preview = await r.text();
  throw new Error("Risposta non-JSON: " + preview.slice(0, 160));
}
const data = await r.json();
```

> Se per qualunque motivo il server tornasse HTML (error page), eviti il crash del parser e ottieni un log chiaro.

---

# Cose che Replit potrebbe chiederti/che valgono come “fix”

* **Bucket**: usare sempre **lo stesso nome** (`wass_assignments`) in tutti gli endpoint.
* **Percorsi/chiavi**: usare chiavi con slash (`dd-mm-YYYY/assignments_ddmmyy.json`) è OK.
* **CORS**: se UI e API girano su domini/porte diversi, abilita CORS per `/api/*`.
* **Proxy dev**: in Vite configura `server.proxy` per `/api` o chiama l’URL assoluto del server.

Se vuoi, ti preparo anche un **diff** unificato contro il tuo `routes.ts` attuale.
