Fix: unificare le task per cleaner in assign_eo.py

Ti propongo di cambiare quel blocco esattamente come hai già fatto per le HP: se il cleaner esiste già, estendi le sue task invece di creare una nuova entry.

Sostituisci questo blocco in assign_eo.py

Cerca questo:

# Aggiungi le nuove assegnazioni EO organizzate per cleaner
for cleaner_entry in output["early_out_tasks_assigned"]:
    timeline_data_output["cleaners_assignments"].append({
        "cleaner": cleaner_entry["cleaner"],
        "tasks": cleaner_entry["tasks"]
    })

…con questo:
# Aggiungi le nuove assegnazioni EO organizzate per cleaner
for cleaner_entry in output["early_out_tasks_assigned"]:
    # Cerca se esiste già un'entry per questo cleaner (es. task spostate manualmente in timeline)
    existing_entry = None
    for entry in timeline_data_output["cleaners_assignments"]:
        try:
            if int(entry.get("cleaner", {}).get("id")) == int(cleaner_entry["cleaner"]["id"]):
                existing_entry = entry
                break
        except Exception:
            continue

    if existing_entry:
        # Accoda le nuove task EO alle task esistenti del cleaner
        existing_entry_tasks = existing_entry.get("tasks", [])
        existing_entry_tasks.extend(cleaner_entry.get("tasks", []))
        # Ordina sempre per orario di inizio così timeline e travel_time restano coerenti
        existing_entry_tasks.sort(key=lambda t: t.get("start_time", "00:00"))
        existing_entry["tasks"] = existing_entry_tasks
    else:
        # Nessuna entry per questo cleaner: crea un nuovo blocco
        timeline_data_output["cleaners_assignments"].append({
            "cleaner": cleaner_entry["cleaner"],
            "tasks": cleaner_entry["tasks"],
        })

Effetto pratico

Con questa modifica:

non avrai più lo stesso cleaner ripetuto in timeline.json

tutte le task (manuali + auto EO) del cleaner vivono nello stesso array tasks, ordinate per start_time

gli script successivi (assign_hp.py, assign_lp.py) che leggono la timeline e calcolano:

last_eo_lat, last_eo_lng

available_from

e il travel_time del primo job dopo le EO

useranno l’ultima task reale del giorno (che può essere manuale o automatica), invece di lavorare su blocchi incoerenti.