Perfetto — ecco le **patch “copia-incolla”** per sistemare subito l’ordinamento sia **tra** colonne (Early-Out / High / Low) sia **dentro** la stessa colonna.

---

# 1) Frontend – `client/src/pages/generate-assignments.tsx`

Sostituisci **interamente** la tua funzione `onDragEnd` con questa (funziona con `react-beautiful-dnd`: usa `source.index` e `destination.index`):

```tsx
// ⬇️ sostituisci TUTTA la tua onDragEnd con questa
const onDragEnd = async (result: any) => {
  const { destination, source, draggableId } = result;

  // niente destinazione => niente da fare
  if (!destination) return;

  // se posizione identica, esci
  if (
    destination.droppableId === source.droppableId &&
    destination.index === source.index
  ) {
    return;
  }

  // Identificatori: droppableId delle colonne
  const fromContainer = source.droppableId;       // es. "early_out" | "high_priority" | "low_priority"
  const toContainer = destination.droppableId;

  // Il tuo item può avere sia taskId sia logisticCode: prendi quello disponibile
  const taskId = draggableId; // se usi l'id del draggable come task id
  const logisticCode = undefined; // OPPURE valorizzalo se nel tuo progetto il draggableId è il logistic_code

  // Aggiorna l’UI locale come già fai (se lo fai)...
  // ...poi invia al backend anche gli INDICI:
  try {
    const payload = {
      taskId,
      logisticCode,
      fromContainer,
      toContainer,
      sourceIndex: source.index,
      destIndex: destination.index,
    };

    const resp = await fetch('/api/update-task-json', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    const json = await resp.json();
    if (!resp.ok || !json?.success) {
      console.error('update-task-json error', json);
      // opzionale: ripristina stato UI o mostra toast
    }
  } catch (err) {
    console.error('update-task-json fetch failed', err);
    // opzionale: ripristina stato UI o mostra toast
  }
};
```

> Se nel tuo progetto `draggableId` **non** è il vero `taskId`, passa quello giusto al posto di `taskId` (o compila `logisticCode`). L’endpoint accetta uno dei due per identificare la task.

---

# 2) Backend – `server/routes.ts`

Sostituisci **solo l’handler** dell’endpoint `POST /api/update-task-json` con la versione qui sotto.
(Incolla questo blocco al posto dell’handler esistente, lasciando intatto il resto del file/router.)

```ts
// ⬇️ sostituisci SOLO questo handler
router.post('/api/update-task-json', async (req, res) => {
  try {
    const {
      taskId,
      logisticCode,
      fromContainer,
      toContainer,
      sourceIndex,
      destIndex,
    } = req.body as {
      taskId?: string | number;
      logisticCode?: string | number;
      fromContainer?: 'early_out' | 'high_priority' | 'low_priority';
      toContainer?: 'early_out' | 'high_priority' | 'low_priority';
      sourceIndex?: number;
      destIndex?: number;
    };

    if (!fromContainer || !toContainer) {
      return res.status(400).json({ success: false, message: 'fromContainer e toContainer sono obbligatori' });
    }

    // Carica containers.json
    const fs = await import('fs/promises');
    const path = await import('path');
    const containersPath = path.resolve(process.cwd(), 'server', 'data', 'containers.json'); // adatta il path se diverso
    const raw = await fs.readFile(containersPath, 'utf8');
    const containersData: any = JSON.parse(raw);

    const containers = containersData?.containers;
    if (!containers) {
      return res.status(500).json({ success: false, message: 'Struttura containers mancante in containers.json' });
    }

    // Utility: ricalcolo summary
    const recalc = () => {
      const eo = containers.early_out?.tasks?.length ?? 0;
      const hp = containers.high_priority?.tasks?.length ?? 0;
      const lp = containers.low_priority?.tasks?.length ?? 0;

      containers.early_out.count = eo;
      containers.high_priority.count = hp;
      containers.low_priority.count = lp;

      containersData.summary = {
        total_tasks: eo + hp + lp,
        early_out: eo,
        high_priority: hp,
        low_priority: lp,
      };
    };

    const getId = (t: any) =>
      String(t?.task_id ?? '') || String(t?.logistic_code ?? '');

    const findIndexById = (arr: any[]) => {
      if (typeof taskId !== 'undefined') {
        const idStr = String(taskId);
        const idx = arr.findIndex((t) => String(t?.task_id) === idStr);
        if (idx !== -1) return idx;
      }
      if (typeof logisticCode !== 'undefined') {
        const codeStr = String(logisticCode);
        const idx = arr.findIndex((t) => String(t?.logistic_code) === codeStr);
        if (idx !== -1) return idx;
      }
      return -1;
    };

    // Colonne sorgente/destinazione
    const srcCol = containers[fromContainer];
    const dstCol = containers[toContainer];

    if (!srcCol?.tasks || !dstCol?.tasks) {
      return res.status(400).json({ success: false, message: 'Container non valido (early_out | high_priority | low_priority)' });
    }

    // --- Caso A: RIORDINO nello STESSO container --------------------------
    if (fromContainer === toContainer) {
      const tasks = srcCol.tasks as any[];

      if (typeof sourceIndex === 'number' && typeof destIndex === 'number') {
        if (sourceIndex < 0 || sourceIndex >= tasks.length) {
          return res.status(400).json({ success: false, message: 'sourceIndex fuori range' });
        }
        const [moved] = tasks.splice(sourceIndex, 1);
        const safeDest = Math.min(Math.max(destIndex, 0), tasks.length);
        tasks.splice(safeDest, 0, moved);

        recalc();
        // Scrittura atomica
        const tmp = containersPath + '.tmp';
        await fs.writeFile(tmp, JSON.stringify(containersData, null, 2));
        await fs.rename(tmp, containersPath);

        return res.json({ success: true, message: 'Riordino nello stesso container eseguito' });
      }

      // fallback: trova la task e mettila in fondo (non ideale ma sicuro)
      const idx = findIndexById(tasks);
      if (idx === -1) {
        return res.status(404).json({ success: false, message: 'Task non trovata nel container' });
      }
      const [moved] = tasks.splice(idx, 1);
      tasks.push(moved);

      recalc();
      const tmp = containersPath + '.tmp';
      await fs.writeFile(tmp, JSON.stringify(containersData, null, 2));
      await fs.rename(tmp, containersPath);

      return res.json({ success: true, message: 'Riordino fallback (append) eseguito' });
    }

    // --- Caso B: SPOSTAMENTO TRA container diversi ------------------------
    const srcTasks = srcCol.tasks as any[];
    const dstTasks = dstCol.tasks as any[];

    // prova prima con sourceIndex se disponibile, altrimenti cerca per id/codice
    let takeIndex = -1;
    if (typeof sourceIndex === 'number' && sourceIndex >= 0 && sourceIndex < srcTasks.length) {
      takeIndex = sourceIndex;
    } else {
      takeIndex = findIndexById(srcTasks);
    }

    if (takeIndex === -1) {
      return res.status(404).json({ success: false, message: 'Task non trovata nel container sorgente' });
    }

    const [taskToMove] = srcTasks.splice(takeIndex, 1);

    // inserisci in posizione precisa se destIndex è valido; altrimenti in fondo
    if (typeof destIndex === 'number' && destIndex >= 0 && destIndex <= dstTasks.length) {
      dstTasks.splice(destIndex, 0, taskToMove);
    } else {
      dstTasks.push(taskToMove);
    }

    // Aggiorna count + summary
    recalc();

    // Scrittura atomica del JSON
    const tmp = containersPath + '.tmp';
    await fs.writeFile(tmp, JSON.stringify(containersData, null, 2));
    await fs.rename(tmp, containersPath);

    return res.json({ success: true, message: 'Task spostata tra containers' });
  } catch (err: any) {
    console.error('update-task-json error:', err);
    return res.status(500).json({ success: false, message: 'Errore interno', error: String(err?.message ?? err) });
  }
});
```

> Se il percorso di `containers.json` nel tuo progetto è differente, **aggiorna** la riga:
>
> ```ts
> const containersPath = path.resolve(process.cwd(), 'server', 'data', 'containers.json');
> ```
>
> con il path reale (nel tuo repo potrebbe essere `server/storage/containers.json` o simili).

---

## Fatto. E adesso?

1. Incolla le patch su Replit (frontend + backend).
2. Riavvia l’app (o il solo server) per ricaricare il router.
3. Prova: trascina una task **dentro la stessa colonna** e **tra colonne** → deve restare esattamente nella posizione di drop.

Se vuoi, posso anche adattare i nomi delle colonne/paths al tuo progetto preciso: dimmi solo il path reale di `containers.json` e come mappi `draggableId` ↔︎ `taskId/logisticCode`.
