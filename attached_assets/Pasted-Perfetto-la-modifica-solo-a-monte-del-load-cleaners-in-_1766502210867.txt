Perfetto — la modifica è solo a monte del “load cleaners” in runPhase2: invece di prendere “tutti i cleaners disponibili”, devi intersecare con quelli presenti in selected_cleaners (nel progetto è gestito via PostgreSQL nella tabella daily_selected_cleaners).

Nel codice del repo c’è già il servizio pronto:

server/services/pg-daily-assignments-service.ts

loadSelectedCleaners(workDate: string): Promise<number[] | null>

legge SELECT cleaners FROM daily_selected_cleaners WHERE work_date = $1

e ritorna un array di ID numerici (integer[])

Quindi FASE 2 deve fare:

selectedCleanerIds = await pgDailyAssignmentsService.loadSelectedCleaners(date)

caricare i cleaners “available” solo tra questi ID

se selectedCleanerIds è null o [] → non assegnare nulla (o fallback deciso da voi, ma di default meglio “zero cleaners” per evitare side-effect/assunzioni).

Patch consigliata (minima) in runPhase2.ts
Step 1 — carica selected cleaners
import { pgDailyAssignmentsService } from "../pg-daily-assignments-service"; // percorso come nel tuo progetto

const selectedCleanerIds = await pgDailyAssignmentsService.loadSelectedCleaners(date);
const selectedIds = selectedCleanerIds ?? [];

if (selectedIds.length === 0) {
  // shadow: niente cleaners selezionati -> niente assegnazioni
  // logga decision e/o aggiorna summary run
  // return con assignedGroups=0 e tutti i gruppi in unassigned candidate
}

Step 2 — filtra i cleaners disponibili

Dipende da come li stai caricando adesso. L’obiettivo è avere una query tipo:

prima prendevi: “cleaners disponibili del giorno”

ora devi fare: “cleaners disponibili del giorno AND id IN selectedIds”

Esempio Postgres:

// esempio: aggiungi un filtro WHERE cleaner_id = ANY($X)
const cleaners = await query(`
  SELECT c.*
  FROM cleaners c
  JOIN cleaner_availability a ON a.cleaner_id = c.id
  WHERE a.work_date = $1
    AND c.id = ANY($2::int[])
`, [date, selectedIds]);


Se invece stai già caricando “tutti i cleaners disponibili” e poi filtrando in JS, va bene comunque (meno efficiente ma semplice):

const allAvailable = await loadAvailableCleaners(date); // la tua funzione attuale
const cleaners = allAvailable.filter(c => selectedIds.includes(c.id));

Step 3 — metti la metrica in summary (utile per debug)

Aggiorna optimizer_run.summary con:

selected_cleaners_count

available_cleaners_count_before_filter

available_cleaners_count_after_filter

Così capisci subito se il problema è “nessun selected_cleaners” vs “selected_cleaners ma non disponibili”.

Nota importante (per evitare bug)

Nel progetto selected_cleaners sono ID (integer), non nomi. Quindi tutta la pipeline Phase2 deve lavorare con cleaner.id.

Comportamento consigliato quando selected_cleaners è vuoto

Io farei così (coerente con shadow e “non inventare”):

0 cleaners → 0 gruppi assegnati

ogni gruppo finisce come PHASE2_GROUP_UNASSIGNED_CANDIDATE con reason NO_SELECTED_CLEANERS