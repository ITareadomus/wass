1) timeline-view.tsx — le task spariscono perché le stai “nascondendo” tu

Nel render della lista, oggi fai due cose:

inserisci provided.placeholder prima di una task a un certo indice

non renderizzi la TaskCard quando quell’indice coincide (quindi la task diventa invisibile)

Questo è esattamente ciò che descrivi (“sparisce”). 

timeline-view

Modifica A — NON nascondere mai la TaskCard

Cerca questo blocco (è vicino al commento “Renderizza TaskCard SOLO se…”):

{/* Renderizza placeholder PRIMA della task all'indice target */}
{draggedTaskIndex !== null && draggedTaskIndex === idx && provided.placeholder}

/* Renderizza TaskCard SOLO se NON è l'indice target del drag */
{! ...


✅ Sostituiscilo con questo (TaskCard sempre renderizzata):

{/* Placeholder solo per mostrare il punto di inserimento */}
{placeholderIndex === idx && provided.placeholder}

{/* TaskCard: non deve mai sparire */}
<TaskCard ... />


Nota: placeholderIndex lo definiamo nella Modifica B qui sotto.

Modifica B — smetti di usare snapshot.draggingOverWith per calcolare l’indice

Il bug “se la porto sopra un’altra task la fa sparire” nasce perché draggingOverWith è l’id della task sopra cui stai passando: quindi tu calcoli l’indice della task “hoverata” e poi la nascondi. (È proprio la dinamica che ti sta fregando.) 

timeline-view

✅ Quindi:

cerca nel file draggedTaskIndex (tutta la logica che lo calcola)

eliminala completamente

rimpiazzala con un indice “pulito” basato sui props che già passi (draggingOverCleanerId, lastValidDragIndex)

Aggiungi prima del render della lista tasks (dentro la map del cleaner, dove hai cleanerTasks):

const placeholderIndex =
  draggingOverCleanerId === cleaner.id && lastValidDragIndex !== null
    ? lastValidDragIndex
    : null;


Poi, dopo il .map() delle task, assicurati che il placeholder venga renderizzato se l’indice è “in coda”:

{(placeholderIndex === null || placeholderIndex >= cleanerTasks.length) && provided.placeholder}


E dentro il .map((task, idx) => ...) metti:

{placeholderIndex === idx && provided.placeholder}
<TaskCard ... />


✅ Risultato: nessuna task sparisce mai, e il placeholder appare solo come “spazio di inserimento”.

2) timeline-view.tsx — fix “a volte non riconosce la fine del movimento”

Hai un overlay di loading che copre tutta la timeline quando isLoadingDragDrop è true: 

timeline-view


Quell’overlay può intercettare eventi del mouse (soprattutto se scatta in momenti sfigati) e lasciare la UI in uno stato “mezzo drag”.

✅ Modifica C — rendi l’overlay “trasparente ai click”
Sostituisci questa riga:

<div className="absolute inset-0 bg-black/20 dark:bg-black/40 rounded-lg flex items-center justify-center z-40 backdrop-blur-sm">


con:

<div className="absolute inset-0 bg-black/20 dark:bg-black/40 rounded-lg flex items-center justify-center z-40 backdrop-blur-sm pointer-events-none">


Così l’overlay si vede ma non blocca mouseup/mousemove.

3) generate-assignments.tsx — evita di attivare il loader quando “non c’è drop”

In onDragEnd attivi subito setIsLoadingDragDrop(true) ancora prima di sapere se destination esiste. 

generate-assignments


In alcuni casi (drop fuori / drag annullato) è meglio non far comparire proprio l’overlay.

✅ Modifica D — sposta setIsLoadingDragDrop(true) dopo i return “veloci”
Trova:

setIsLoadingDragDrop(true);

const { destination, source, draggableId } = result;

try {
  if (!destination) {
    return;
  }
  ...


e trasformalo così:

const { destination, source, draggableId } = result;

// niente destinazione => niente da fare (e NON mostrare overlay)
if (!destination) return;

// se posizione identica, esci
if (
  destination.droppableId === source.droppableId &&
  destination.index === source.index
) return;

// solo ora ha senso mostrare overlay
setIsLoadingDragDrop(true);

try {
  ...
} finally {
  isDraggingRef.current = false;
  if (dragTimeoutRef.current) clearTimeout(dragTimeoutRef.current);
  setIsLoadingDragDrop(false);
}

Checklist finale (scaletta Replit)

timeline-view.tsx

 elimina tutta la logica di draggedTaskIndex

 aggiungi placeholderIndex basato su draggingOverCleanerId + lastValidDragIndex

 rimuovi qualunque condizione che impedisce il render della TaskCard (TaskCard sempre visibile)

 renderizza provided.placeholder una sola volta, o all’indice placeholderIndex o in fondo

 aggiungi pointer-events-none all’overlay di loading

generate-assignments.tsx

 sposta setIsLoadingDragDrop(true) dopo i return “no destination / same position”