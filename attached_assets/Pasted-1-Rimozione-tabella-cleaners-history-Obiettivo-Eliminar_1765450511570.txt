1️⃣ Rimozione tabella cleaners_history
Obiettivo

Eliminare completamente la tabella cleaners_history perché non serve più.

Aggiornare il codice che la usa (se esiste) per lavorare solo con cleaners.

SQL di migrazione
-- 1.1: eliminare eventuali vincoli o foreign key che puntano a cleaners_history
-- (se non ce ne sono, questo blocco non serve)
-- Esempio: ALTER TABLE some_table DROP CONSTRAINT IF EXISTS some_fk_name;

-- 1.2: drop della tabella cleaners_history
DROP TABLE IF EXISTS cleaners_history;

Modifiche al codice (da far fare a Replit)

Cercare tutte le occorrenze di cleaners_history nel codice:

rimuovere eventuali query di insert/select/cleanup sulla tabella.

se serviva per lo storico, ora usare direttamente:

SELECT * FROM cleaners WHERE work_date = $1;


Se esiste un modello/typing (es. Prisma/TypeScript) per cleaners_history, eliminarlo.

2️⃣ Creazione tabella selected_cleaners_revisions
Obiettivo

Tenere traccia di tutte le modifiche fatte alla selezione giornaliera (selected_cleaners):

rimozione di cleaners

aggiunta

swap

rollback

SQL di migrazione
CREATE TABLE IF NOT EXISTS selected_cleaners (
  id SERIAL PRIMARY KEY,
  work_date DATE NOT NULL UNIQUE,
  cleaners INTEGER[] NOT NULL DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS selected_cleaners_revisions (
  id SERIAL PRIMARY KEY,
  selected_cleaners_id INTEGER NOT NULL
    REFERENCES selected_cleaners(id) ON DELETE CASCADE,
  work_date DATE NOT NULL,
  revision_number INTEGER NOT NULL,
  cleaners_before INTEGER[] NOT NULL,
  cleaners_after  INTEGER[] NOT NULL,
  action_type VARCHAR(30) NOT NULL,   -- 'REMOVE', 'ADD', 'SWAP', 'ROLLBACK', ...
  action_payload JSONB,               -- dettagli extra, es: {"removed": 123}
  performed_by VARCHAR(100),
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE (selected_cleaners_id, revision_number)
);

CREATE INDEX IF NOT EXISTS idx_sel_cleaners_revisions_date
  ON selected_cleaners_revisions(work_date);

Modifiche al codice (far fare a Replit)

Ogni volta che si modifica selected_cleaners.cleaners:

Prima di aggiornare l’array:

leggere lo stato corrente → before.

calcolare l’array modificato → after.

Calcolare revision_number:

COALESCE(MAX(revision_number), 0) + 1 per quel selected_cleaners_id.

Inserire una riga in selected_cleaners_revisions con:

selected_cleaners_id

work_date

revision_number

cleaners_before = before

cleaners_after = after

action_type ('REMOVE', 'ADD', 'SWAP', ecc.)

action_payload (JSON con i dettagli)

Aggiornare selected_cleaners.cleaners = after.

Rollback:

Funzione/endpoint che:

prende selected_cleaners_id (o work_date) e revision_number da cui tornare;

legge cleaners_before o cleaners_after (decidiamo di usare cleaners_before come “stato a cui tornare”, più intuitivo);

fa UPDATE selected_cleaners SET cleaners = cleaners_before;

opzionale: crea una nuova revision con action_type = 'ROLLBACK'.

3️⃣ Creazione tabella cleaner_aliases + rimozione campo alias
Obiettivo

Spostare gli alias dei cleaners in una tabella dedicata e permanente.

Rimuovere il campo alias dalla tabella (es. cleaners) e dal codice.

SQL di migrazione
-- 3.1: creare tabella cleaner_aliases
CREATE TABLE IF NOT EXISTS cleaner_aliases (
  cleaner_id INTEGER PRIMARY KEY,
  alias VARCHAR(100) NOT NULL,
  name VARCHAR(255),
  lastname VARCHAR(255),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 3.2: rimozione campo alias dalla/e tabella/e dove è presente
-- Ad esempio se alias è in cleaners:
ALTER TABLE cleaners
  DROP COLUMN IF EXISTS alias;


Se l’alias è in un’altra tabella (tipo daily_cleaners o altro), Replit dovrà adattare l’ALTER TABLE a quella corretta.

Facoltativo – Import da JSON

Se esiste un file tipo cleaners_aliases.json con la struttura:

{
  "aliases": {
    "24": { "name": "HUSSAIN", "lastname": "SYED SHUJIAHAT", "alias": "SYED" },
    "132": { "name": "JOHOISER ERNESTO", "lastname": "LOPEZ GIRON", "alias": "LOPEZ" }
  }
}


far fare a Replit uno script (Node/TS o SQL) che:

legge il JSON,

per ogni voce fa:

INSERT INTO cleaner_aliases (cleaner_id, alias, name, lastname)
VALUES ($1, $2, $3, $4)
ON CONFLICT (cleaner_id) DO UPDATE
  SET alias = EXCLUDED.alias,
      name = EXCLUDED.name,
      lastname = EXCLUDED.lastname,
      updated_at = NOW();

Modifiche al codice (far fare a Replit)

Rimuovere l’uso di alias dal modello cleaners:

aggiornare eventuali ORM/schema (Prisma, Drizzle, ecc.).

aggiornare tipi TypeScript/JS dove alias era presente su cleaner.

Quando si costruisce la risposta per la UI (nome del cleaner):

per ogni cleaner_id:

cercare prima in cleaner_aliases:

SELECT alias FROM cleaner_aliases WHERE cleaner_id = $1;


se esiste → usare alias.

altrimenti → usare name + lastname da cleaners.

Se c’erano funzioni che scrivevano l’alias direttamente in cleaners:

aggiornarle per scrivere/aggiornare su cleaner_aliases invece.

Mini-riassunto per Replit (versione brevissima da incollare)

Step 1 – DB

Droppare tabella cleaners_history.

Creare tabella selected_cleaners_revisions (schema sopra).

Creare tabella cleaner_aliases (schema sopra).

Rimuovere il campo alias da cleaners (o dalla tabella effettiva dove si trova).

Step 2 – Codice

Eliminare ogni uso di cleaners_history.

Aggiornare la logica che modifica selected_cleaners.cleaners per salvare una riga in selected_cleaners_revisions ad ogni modifica.

Aggiungere una funzione di rollback usando selected_cleaners_revisions.

Spostare l’uso degli alias su cleaner_aliases:

leggere alias per cleaner_id da quella tabella;

salvare eventuali modifiche di alias lì;

eliminare il campo alias dai modelli/typing dei cleaners.