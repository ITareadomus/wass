le checkbox “Tipo A/B/C…” nella pagina /settings → Apartment Types devono diventare vincoli reali per gli script di assegnazione EO/HP/LP.

Ti propongo una soluzione pulita:

usiamo solo settings.json come sorgente di verità

centralizziamo la logica in task_validation.py

applichiamo il controllo in tutti e tre gli script: assign_eo.py, assign_hp.py, assign_lp.py

nessuna modifica alla UI: le checkbox già salvano apartment_types nel formato giusto ✅

1. Semantica che implementiamo

Leggiamo da settings.json:

"apartment_types": {
  "standard_apt": ["A", "B", "C", "D", "E", "F", "X"],
  "premium_apt":  ["B", "C", "D", "E", "F", "X", "A"],
  "formatore_apt": ["B", "C"]
}


e la interpretiamo così:

standard_apt → lettere che può pulire un Cleaner Standard

premium_apt → lettere che può pulire un Cleaner Premium

formatore_apt → lettere che può pulire un Cleaner Formatore

In codice:

role == "Standard" → usa standard_apt

role == "Premium" → usa premium_apt

role == "Formatore" → usa formatore_apt

Se in futuro togli una lettera dalla colonna “Cleaner Formatori”, gli script smetteranno di assegnare quegli appartamenti ai Formatori.

2. PATCH 1 – Estendere task_validation.py

File:
client/public/scripts/task_validation.py

2.1. Importa List

In testa al file hai:

from typing import Dict, Optional


➡️ Cambia in:

from typing import Dict, Optional, List

2.2. Aggiungi apartment_types nella classe

Subito dentro __init__:

class TaskValidationRules:
    """Gestisce le regole di validazione task_types da settings.json"""
    
    def __init__(self):
        self.rules: Dict[str, Dict[str, bool]] = {}
        self.load_rules()


➡️ Diventa:

class TaskValidationRules:
    """Gestisce le regole di validazione task_types e apartment_types da settings.json"""
    
    def __init__(self):
        self.rules: Dict[str, Dict[str, bool]] = {}
        # mappa: "standard_cleaner" -> ["A","B",...]
        self.apartment_types: Dict[str, List[str]] = {}
        self.load_rules()

2.3. Leggere anche apartment_types in load_rules

La funzione load_rules oggi è:

    def load_rules(self) -> None:
        """Carica le regole task_types da settings.json"""
        try:
            with open(SETTINGS_PATH, 'r', encoding='utf-8') as f:
                settings = json.load(f)
                self.rules = settings.get('task_types', {})
        except FileNotFoundError:
            print(f"⚠️ Warning: {SETTINGS_PATH} not found, using empty rules")
            self.rules = {}
...


➡️ Sostituiscila con:

    def load_rules(self) -> None:
        """Carica le regole task_types e apartment_types da settings.json"""
        try:
            with open(SETTINGS_PATH, 'r', encoding='utf-8') as f:
                settings = json.load(f)
                self.rules = settings.get('task_types', {}) or {}

                # Nuovo: mappatura lettere appartamenti per ruolo cleaner
                apt_settings = settings.get('apartment_types', {}) or {}

                # Normalizziamo in maiuscolo, e mappiamo alle chiavi ruolo normalizzate
                self.apartment_types = {}

                def _norm_letters(key: str) -> List[str]:
                    values = apt_settings.get(key)
                    if values is None:
                        return None  # chiave non configurata
                    return [str(x).upper() for x in values]

                std = _norm_letters("standard_apt")
                if std is not None:
                    self.apartment_types["standard_cleaner"] = std

                prem = _norm_letters("premium_apt")
                if prem is not None:
                    self.apartment_types["premium_cleaner"] = prem

                fmt = _norm_letters("formatore_apt")
                if fmt is not None:
                    self.apartment_types["formatore_cleaner"] = fmt

        except FileNotFoundError:
            print(f"⚠️ Warning: {SETTINGS_PATH} not found, using empty rules")
            self.rules = {}
            self.apartment_types = {}
        except json.JSONDecodeError as e:
            print(f"⚠️ Warning: Error parsing {SETTINGS_PATH}: {e}")
            self.rules = {}
            self.apartment_types = {}


Nota importante:

se una chiave non esiste in settings.json → non viene messa in self.apartment_types → nessun vincolo per quel ruolo.

se una chiave esiste ma è una lista vuota [] → è vincolo “nessuna lettera permessa” per quel ruolo.

2.4. Nuovo metodo: can_cleaner_handle_apartment

Subito dopo can_cleaner_handle_task (dopo il blocco che hai già), aggiungi:

    def can_cleaner_handle_apartment(self, cleaner_role: str, apt_type: Optional[str]) -> bool:
        """
        Verifica se un cleaner può gestire un appartamento in base alle lettere configurate
        in settings.apartment_types.

        - Se apt_type è None/vuoto → non blocca (True)
        - Se per quel ruolo non è configurato nulla → non blocca (True)
        - Se per quel ruolo è configurata una lista (anche vuota) → permette solo le lettere in lista
        """
        if not apt_type:
            return True

        cleaner_key = self._normalize_cleaner_role(cleaner_role)
        allowed = self.apartment_types.get(cleaner_key)

        # Nessuna configurazione per questo ruolo → non applichiamo vincolo
        if allowed is None:
            return True

        return apt_type.upper() in allowed

2.5. Funzione di convenience globale

In fondo al file, dopo:

def can_cleaner_handle_task(cleaner_role: str, task_type: str) -> bool:
    """Wrapper convenience per la validazione"""
    return get_validation_rules().can_cleaner_handle_task(cleaner_role, task_type)


aggiungi:

def can_cleaner_handle_apartment(cleaner_role: str, apt_type: Optional[str]) -> bool:
    """Wrapper convenience per la compatibilità appartamento-lettera"""
    return get_validation_rules().can_cleaner_handle_apartment(cleaner_role, apt_type)


(la Optional è già importata in testa, quindi ok).

3. PATCH 2 – Usare i vincoli di appartamento in assign_eo.py

File:
client/public/scripts/assign_eo.py

3.1. Importa la nuova funzione

In testa oggi hai:

from task_validation import can_cleaner_handle_task


➡️ Cambia in:

from task_validation import can_cleaner_handle_task, can_cleaner_handle_apartment

3.2. Fast-path “stesso edificio”

Blocchetto intorno a riga ~580:

        if same_building_cleaner:
            # VALIDAZIONE: Verifica compatibilità anche per fast-path stesso edificio
            task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')
            if not can_cleaner_handle_task(same_building_cleaner.role, task_type):
                print(f"   ⚠️  Same-building cleaner {same_building_cleaner.name} ({same_building_cleaner.role}) non può gestire task {task_type} - SKIPPATO fast-path")
            else:
                result = find_best_position(same_building_cleaner, task)


➡️ Sostituisci con:

        if same_building_cleaner:
            # VALIDAZIONE: Verifica compatibilità tipo task + tipo appartamento (lettera)
            task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')

            if not can_cleaner_handle_task(same_building_cleaner.role, task_type):
                print(f"   ⚠️  Same-building cleaner {same_building_cleaner.name} ({same_building_cleaner.role}) non può gestire task {task_type} - SKIPPATO fast-path")
            elif not can_cleaner_handle_apartment(same_building_cleaner.role, task.apt_type):
                print(f"   ⚠️  Same-building cleaner {same_building_cleaner.name} ({same_building_cleaner.role}) non può gestire appartamento {task.apt_type} - SKIPPATO fast-path")
            else:
                result = find_best_position(same_building_cleaner, task)

3.3. Loop principale dei candidati EO

Blocchetto attuale:

        for cleaner in cleaners:
            # VALIDAZIONE: Verifica se il cleaner può gestire questo tipo di task
            task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')
            if not can_cleaner_handle_task(cleaner.role, task_type):
                print(f"   ⚠️  Cleaner {cleaner.name} ({cleaner.role}) non può gestire task {task_type} - SKIPPATO")
                continue

            result = find_best_position(cleaner, task)
            if result is not None:
                pos, travel = result
                candidates.append((cleaner, pos, travel))


➡️ Diventa:

        for cleaner in cleaners:
            # VALIDAZIONE: tipo di task (standard/premium/straordinaria)
            task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')
            if not can_cleaner_handle_task(cleaner.role, task_type):
                print(f"   ⚠️  Cleaner {cleaner.name} ({cleaner.role}) non può gestire task {task_type} - SKIPPATO")
                continue

            # NUOVO: VALIDAZIONE appartamento (lettera A/B/C...) da settings.apartment_types
            if not can_cleaner_handle_apartment(cleaner.role, task.apt_type):
                print(f"   ⚠️  Cleaner {cleaner.name} ({cleaner.role}) non può gestire appartamento {task.apt_type} - SKIPPATO")
                continue

            result = find_best_position(cleaner, task)
            if result is not None:
                pos, travel = result
                candidates.append((cleaner, pos, travel))

4. PATCH 3 – Usare i vincoli in assign_hp.py

File:
client/public/scripts/assign_hp.py

4.1. Import

In testa:

from task_validation import can_cleaner_handle_task


➡️ diventa:

from task_validation import can_cleaner_handle_task, can_cleaner_handle_apartment

4.2. Fast-path cross-container (stesso edificio / stessa zona)

Intorno alle righe 753–759:

        if target_cleaner:
            # VALIDAZIONE: Verifica compatibilità anche per fast-path cross-container
            task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')
            if not can_cleaner_handle_task(target_cleaner.role, task_type):
                tipo = "edificio" if same_building_cleaner else "zona"
                print(f"   ⚠️  Cross-container {tipo} cleaner {target_cleaner.name} ({target_cleaner.role}) non può gestire task {task_type} - SKIPPATO fast-path")
            else:
                result = find_best_position(target_cleaner, task)


➡️ sostituisci con:

        if target_cleaner:
            # VALIDAZIONE: tipo di task + tipo appartamento
            task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')
            if not can_cleaner_handle_task(target_cleaner.role, task_type):
                tipo = "edificio" if same_building_cleaner else "zona"
                print(f"   ⚠️  Cross-container {tipo} cleaner {target_cleaner.name} ({target_cleaner.role}) non può gestire task {task_type} - SKIPPATO fast-path")
            elif not can_cleaner_handle_apartment(target_cleaner.role, task.apt_type):
                tipo = "edificio" if same_building_cleaner else "zona"
                print(f"   ⚠️  Cross-container {tipo} cleaner {target_cleaner.name} ({target_cleaner.role}) non può gestire appartamento {task.apt_type} - SKIPPATO fast-path")
            else:
                result = find_best_position(target_cleaner, task)

4.3. Forced assignment stessa zona

Blocchetto 772–777:

                    if same_zone_cleaner:
                        # VALIDAZIONE: Verifica compatibilità anche per forced assignment
                        task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')
                        if not can_cleaner_handle_task(same_zone_cleaner.role, task_type):
                            print(f"   ⚠️  Forced assignment: cleaner {same_zone_cleaner.name} ({same_zone_cleaner.role}) non può gestire task {task_type} - SKIPPATO")
                        else:
                            ...


➡️ Diventa:

                    if same_zone_cleaner:
                        # VALIDAZIONE: tipo + appartamento anche per forced assignment
                        task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')
                        if not can_cleaner_handle_task(same_zone_cleaner.role, task_type):
                            print(f"   ⚠️  Forced assignment: cleaner {same_zone_cleaner.name} ({same_zone_cleaner.role}) non può gestire task {task_type} - SKIPPATO")
                        elif not can_cleaner_handle_apartment(same_zone_cleaner.role, task.apt_type):
                            print(f"   ⚠️  Forced assignment: cleaner {same_zone_cleaner.name} ({same_zone_cleaner.role}) non può gestire appartamento {task.apt_type} - SKIPPATO")
                        else:
                            ...


(mantieni il resto del blocco invariato sotto else:)

4.4. Loop principale HP

Blocchetto 799–805:

        for cleaner in cleaners:
            # VALIDAZIONE: Verifica se il cleaner può gestire questo tipo di task
            task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')
            if not can_cleaner_handle_task(cleaner.role, task_type):
                print(f"   ⚠️  Cleaner {cleaner.name} ({cleaner.role}) non può gestire task {task_type} - SKIPPATO")
                continue

            result = find_best_position(cleaner, task)
            ...


➡️ Diventa:

        for cleaner in cleaners:
            # VALIDAZIONE: tipo di task
            task_type = 'straordinario_apt' if task.straordinaria else ('premium_apt' if task.is_premium else 'standard_apt')
            if not can_cleaner_handle_task(cleaner.role, task_type):
                print(f"   ⚠️  Cleaner {cleaner.name} ({cleaner.role}) non può gestire task {task_type} - SKIPPATO")
                continue

            # NUOVO: VALIDAZIONE appartamento
            if not can_cleaner_handle_apartment(cleaner.role, task.apt_type):
                print(f"   ⚠️  Cleaner {cleaner.name} ({cleaner.role}) non può gestire appartamento {task.apt_type} - SKIPPATO")
                continue

            result = find_best_position(cleaner, task)
            ...

5. PATCH 4 – Usare i vincoli in assign_lp.py (LP)

File:
client/public/scripts/assign_lp.py

5.1. Import

In testa:

from task_validation import can_cleaner_handle_task


➡️ diventa:

from task_validation import can_cleaner_handle_task, can_cleaner_handle_apartment

5.2. Regole in can_add_task (Formatore + tutti gli altri)

Trovi la docstring:

def can_add_task(cleaner: Cleaner, task: Task) -> bool:
    """
    Verifica se è possibile aggiungere una task al cleaner secondo le regole:
    1. Premium task -> premium cleaner
    2. Straordinaria -> premium cleaner, deve essere la prima (pos=0)
    3. CLUSTERING: appartamenti vicini (≤10') possono infrangere limiti tipologia
    4. Stessa via o ≤5': massima priorità cluster
    5. Limite giornaliero: max 5 task totali (EO+HP+LP)
    6. FORMATORE: solo task con type_apt A o B, massimo 2 al giorno
    """
    # NUOVO: Regole per Formatore
    if cleaner.role.lower() == "formatore":
        # Formatore può solo task type_apt A o B
        if task.apt_type not in ["A", "B"]:
            return False
        # Formatore max 2 task LP al giorno (totale)
        if len(cleaner.route) >= 2:
            return False


➡️ Sostituiscilo con:

def can_add_task(cleaner: Cleaner, task: Task) -> bool:
    """
    Verifica se è possibile aggiungere una task al cleaner secondo le regole:
    1. Premium task -> premium cleaner
    2. Straordinaria -> premium cleaner, deve essere la prima (pos=0)
    3. CLUSTERING: appartamenti vicini (≤10') possono infrangere limiti tipologia
    4. Stessa via o ≤5': massima priorità cluster
    5. Limite giornaliero: max 5 task totali (EO+HP+LP)
    6. FORMATORE: solo task con type_apt consentiti in settings.apartment_types.formatore_apt, massimo 2 al giorno
    """
    # Regola 0: compatibilità appartamento/ruolo da settings.apartment_types
    if not can_cleaner_handle_apartment(cleaner.role, task.apt_type):
        return False

    # Regole specifiche per Formatore
    if cleaner.role.lower() == "formatore":
        # Formatore max 2 task LP al giorno (totale)
        if len(cleaner.route) >= 2:
            return False


Il resto della funzione (limiti giornalieri, straordinaria in posizione 0, clustering, ecc.) resta uguale.

5.3. Applicare il vincolo anche nelle altre assegnazioni LP

Più in basso, dove LP usa can_cleaner_handle_task (incrocio EO/HP/LP), aggiungi il controllo appartamento come fatto per EO/HP.

Esempio nel blocco cross-container:

            if not can_cleaner_handle_task(target_cleaner.role, task_type):
                ...


➡️ dopo questo if, aggiungi:

            elif not can_cleaner_handle_apartment(target_cleaner.role, task.apt_type):
                print(f"   ⚠️  Cross-container cleaner {target_cleaner.name} ({target_cleaner.role}) non può gestire appartamento {task.apt_type} - SKIPPATO fast-path")


E nei loop generici:

        for cleaner in cleaners:
            if not can_cleaner_handle_task(cleaner.role, task_type):
                ...
                continue

            if not can_cleaner_handle_apartment(cleaner.role, task.apt_type):
                print(f"   ⚠️  Cleaner {cleaner.name} ({cleaner.role}) non può gestire appartamento {task.apt_type} - SKIPPATO")
                continue

6. Risultato finale (come ti funziona in pratica)

Dopo questi patch:

Quando in /settings → Apartment Types:

spunti “Tipo A” nella colonna Cleaner Formatori → "A" finisce in settings.apartment_types.formatore_apt

togli “Tipo B” → "B" viene rimosso dalla lista

In tutti gli script (assign_eo, assign_hp, assign_lp):

quando valutano se un cleaner può prendere una task, controllano ora due cose:

compatibilità tipo di task (task_types: standard/premium/straordinario)

compatibilità lettera appartamento (apartment_types per ruolo)

Se una combinazione è vietata, vedrai log tipo:

Cleaner Mario (Formatore) non può gestire appartamento A - SKIPPATO