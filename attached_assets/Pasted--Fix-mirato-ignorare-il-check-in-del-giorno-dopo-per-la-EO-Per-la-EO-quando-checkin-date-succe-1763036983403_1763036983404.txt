‚úÖ Fix mirato: ignorare il check-in del giorno dopo per la EO

Per la EO, quando checkin_date √® successivo al giorno di checkout (o al giorno di lavoro), quello slot 15:00 non √® un vincolo del giorno corrente: puoi pulire fino alle 19:00 senza problemi.

Quindi, per le EO:

Se checkin_date > checkout_date, non dobbiamo imporre il vincolo ‚Äúfinire prima delle 15:00‚Äù.

Lo facciamo in due punti:

1Ô∏è‚É£ Aggiusta i campi in load_tasks()

Subito dopo aver calcolato checkin_dt e checkout_dt, prima del tasks.append(...), aggiungi:

        # --- FIX: check-in del giorno successivo ---
        # Se il check-in √® il giorno dopo il checkout, il limite "15:00" non vale per il giorno della pulizia.
        # In quel caso:
        #  - alziamo checkin_time al massimo (23:59) per il giorno corrente
        #  - e NON usiamo checkin_dt per vincoli sul giorno corrente
        if checkin_dt and checkout_dt and checkin_dt.date() > checkout_dt.date():
            # Nessun limite di check-in nel giorno della pulizia: si pu√≤ lavorare fino alle 19:00
            checkin = hhmm_to_min("23:59", default="23:59")
            checkin_dt_effective = None
        else:
            checkin_dt_effective = checkin_dt


E nel Task(...) usa checkin_dt_effective:

        tasks.append(
            Task(
                task_id=str(t.get("task_id")),
                logistic_code=str(t.get("logistic_code")),
                lat=float(t.get("lat")),
                lng=float(t.get("lng")),
                cleaning_time=int(t.get("cleaning_time") or 45),
                checkout_time=checkout,
                checkin_time=checkin,
                is_premium=bool(t.get("premium", False)),
                checkin_dt=checkin_dt_effective,
                checkout_dt=checkout_dt,
                apt_type=t.get("type_apt"),
                address=t.get("address"),
                ...
            )
        )


Effetto:

per i casi normali (check-in stesso giorno) ‚Üí tutto come prima.

per i casi ‚Äúcheck-in il giorno dopo‚Äù ‚Üí checkin_time diventa 23:59, checkin_dt non viene usato in evaluate_route.

2Ô∏è‚É£ (Pulizia opzionale) semplifica il controllo in evaluate_route

Volendo, puoi anche semplificare i due controlli di check-in in evaluate_route cos√¨:

        # Check-in strict: applica SOLO se abbiamo un limite valido per il giorno corrente
        effective_checkin_limit = None

        # Se abbiamo un checkin_dt "valido" (stesso giorno), in load_tasks l'abbiamo lasciato,
        # altrimenti √® None. In quel caso usiamo la sola t.checkin_time.
        if hasattr(t, "checkin_dt") and t.checkin_dt:
            effective_checkin_limit = t.checkin_dt.hour * 60 + t.checkin_dt.minute
        elif t.checkin_time and t.checkin_time < 24 * 60:
            effective_checkin_limit = t.checkin_time

        if effective_checkin_limit is not None and finish > effective_checkin_limit:
            return False, []


E puoi togliere i due blocchi duplicati (if finish >= t.checkin_time e il secondo con checkin_dt) in favore di questo unico check.

Se mantieni il fix in load_tasks, questo step √® ‚Äúdi bellezza‚Äù, non obbligatorio: il problema del giorno dopo √® gi√† risolto dal primo fix.

üéØ Cosa cambia per 754 e 795

Immaginando che:

754 = EO oggi con checkout 10:00, check-in domani 15:00

795 = un‚Äôaltra task vicinissima (stessa via / stessa zona) in un altro container

Prima del fix:

per 754 la EO vede ‚Äúlimite 15:00 oggi‚Äù ‚Üí la route del cleaner che gi√† ha altre EO pu√≤ non riuscire a inserirla oltre quell‚Äôora.

quel cleaner non ottiene la combinazione ‚Äú754+795‚Äù quando il planner prova a montarci sopra 795 ‚Üí il clustering cross-container geografico viene ‚Äústrozzato‚Äù.

Dopo il fix:

per 754, essendo check-in il giorno dopo, il limite effettivo diventa 23:59 / nessun vincolo nel giorno corrente ‚Üí la route pu√≤ spingersi tranquillamente verso il pomeriggio.

il cleaner che ha gi√† 754 rimane un candidato valido anche pi√π tardi nella giornata.

quando passa il container successivo (HP/LP) e arriva 795:

il clustering cross-container per stessa zona riconosce che il cleaner con 754 √® il migliore

evaluate_route non scarta pi√π la combinazione per via del finto limite 15:00

795 pu√≤ essere inserita nella stessa route ‚Üí 754 e 795 finiscono sullo stesso cleaner.