Hai centrato il bug: non è nel drag & drop, ma nel codice di riassegnazione automatica (gli script Python assign_eo.py / assign_hp.py / assign_lp.py).

Quando premi il bottone “Assegna” su un container, lo script:

Legge la timeline.json esistente

Calcola le nuove assegnazioni per quel container

Pulisce alcune cose nella timeline

Scrive le nuove assegnazioni

L’errore è al punto 3: per i cleaner a cui sta riassegnando, butta via l’intero blocco del cleaner, non solo le task di quel tipo (EO/HP/LP).
Poi ri-aggiunge solo le nuove task di quel container → il cleaner perde tutte le altre task (quindi il totale passa da 29 a 27, ecc).

Dove sta esattamente l’errore
1. assign_eo.py

Nel file:

client/public/scripts/assign_eo.py

c’è questo pezzo (semplifico, ma è lui):

timeline_data = {
    "metadata": {...},
    "cleaners_assignments": [],
    "meta": {...}
}

if timeline_path.exists():
    try:
        existing = json.loads(timeline_path.read_text(encoding="utf-8"))
        # Mantieni le assegnazioni esistenti non-EO (rimuovi quelle con task EO)
        if "cleaners_assignments" in existing:
            # Crea un set di cleaner_id che avranno nuove assegnazioni EO
            new_eo_cleaner_ids = set(
                c["cleaner"]["id"] for c in output["early_out_tasks_assigned"]
            )
            timeline_data["cleaners_assignments"] = [
                c for c in existing.get("cleaners_assignments", [])
                if c["cleaner"]["id"] not in new_eo_cleaner_ids
                or not any(
                    t.get("reasons")
                    and "automatic_assignment_eo" in t.get("reasons", [])
                    for t in c.get("tasks", [])
                )
            ]


Questa comprensione di lista dice:

Tieni gli entry dei cleaner se:

il loro cleaner.id non è tra quelli che avranno nuove EO, oppure

non hanno nessuna task con reason automatic_assignment_eo.

Tradotto:
per un cleaner che:

è in new_eo_cleaner_ids e

ha almeno una task EO automatica,

entrambi i test falliscono ⇒ quella cleaner_assignment viene completamente rimossa da timeline_data["cleaners_assignments"].

Poi, più sotto, quando fai:

for cleaner_entry in output["early_out_tasks_assigned"]:
    # cerca existing_entry nella timeline_data
    ...
    if existing_entry:
        # merge sofisticato (EO vecchie, HP, LP, manuali...)
    else:
        # Crea nuova entry
        timeline_data["cleaners_assignments"].append({
            "cleaner": cleaner_entry["cleaner"],
            "tasks": cleaner_entry["tasks"]
        })


per quei cleaner che avevi appena eliminato, existing_entry non esiste più, quindi vai sempre nell’else e ricrei il cleaner solo con le nuove EO, buttando via:

tutte le HP,

tutte le LP,

tutte le manuali,

e anche le EO vecchie non duplicate che volevi eventualmente tenere.

Ecco perché nel tuo caso:

Trascini una task dalla timeline al container → la togli dalla timeline (ok, -1 task).

Premi “Assegna” sul container → assign_eo.py ricalcola le EO, cancella l’intero blocco di quel cleaner e ci rimette solo le nuove EO → altre task di quel cleaner spariscono, e il totale scende ulteriormente (29 → 27).

2. Lo stesso bug è copiato anche per HP e LP

In:

client/public/scripts/assign_hp.py

client/public/scripts/assign_lp.py

c’è lo stesso identico pattern:

# HP
timeline_data["cleaners_assignments"] = [
    c for c in existing.get("cleaners_assignments", [])
    if c["cleaner"]["id"] not in new_hp_cleaner_ids
    or not any("automatic_assignment_hp" in t.get("reasons", []) for t in c.get("tasks", []))
]

# LP
timeline_data["cleaners_assignments"] = [
    c for c in existing.get("cleaners_assignments", [])
    if c["cleaner"]["id"] not in new_lp_cleaner_ids
    or not any("automatic_assignment_lp" in t.get("reasons", []) for t in c.get("tasks", []))
]


Quindi lo stesso problema può verificarsi anche quando rilanci l’assegnazione automatica di HP o LP.

Come correggere il bug

L’idea giusta è:

NON eliminare l’intero cleaner quando riassegni EO/HP/LP.

Lascia la lista cleaners_assignments intatta e usa la logica di merge che hai già scritto (quella con eo_tasks_old, hp_tasks, lp_tasks, manual_tasks, ecc.) per sostituire SOLO le task di quel tipo.

Fix minimale per assign_eo.py

Sostituisci questo blocco:

if timeline_path.exists():
    try:
        existing = json.loads(timeline_path.read_text(encoding="utf-8"))
        # Mantieni le assegnazioni esistenti non-EO (rimuovi quelle con task EO)
        if "cleaners_assignments" in existing:
            # Crea un set di cleaner_id che avranno nuove assegnazioni EO
            new_eo_cleaner_ids = set(c["cleaner"]["id"] for c in output["early_out_tasks_assigned"])
            timeline_data["cleaners_assignments"] = [
                c for c in existing.get("cleaners_assignments", [])
                if c["cleaner"]["id"] not in new_eo_cleaner_ids or
                   not any(t.get("reasons") and "automatic_assignment_eo" in t.get("reasons", []) for t in c.get("tasks", []))
            ]
    except Exception as e:
        ...


con qualcosa di molto più semplice, tipo:

if timeline_path.exists():
    try:
        existing = json.loads(timeline_path.read_text(encoding="utf-8"))
        if "cleaners_assignments" in existing:
            # Mantieni TUTTI i cleaner così come sono;
            # il filtraggio delle vecchie EO lo facciamo
            # dentro il blocco existing_entry più sotto.
            timeline_data["cleaners_assignments"] = existing.get("cleaners_assignments", [])
    except Exception as e:
        print(f"⚠️ Errore nel caricamento della timeline esistente: {e}")


La logica nel blocco successivo:

if existing_entry:
    eo_tasks_old = [...]
    hp_tasks = [...]
    lp_tasks = [...]
    manual_tasks = [...]
    new_eo_task_ids = ...
    eo_tasks_to_keep = [ ... if task_id not in new_eo_task_ids ]
    existing_entry["tasks"] = eo_tasks_to_keep + cleaner_entry["tasks"] + hp_tasks + lp_tasks + manual_tasks
    # sort + resequence


è già sufficiente a:

rimuovere/aggiornare solo le EO che stai riassegnando,

mantenere HP, LP e manuali intatte,

evitare duplicati.

Stesso fix per HP / LP

Fai la stessa cosa in:

assign_hp.py (rimuovendo la lista filtrata su new_hp_cleaner_ids)

assign_lp.py (rimuovendo la lista filtrata su new_lp_cleaner_ids)

In entrambi i casi, invece di filtrare i cleaner, copi semplicemente existing["cleaners_assignments"] dentro timeline_data["cleaners_assignments"], e lasci lavorare la logica di merge già presente.