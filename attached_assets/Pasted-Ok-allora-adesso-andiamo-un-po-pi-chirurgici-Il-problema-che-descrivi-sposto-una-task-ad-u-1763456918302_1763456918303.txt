Ok, allora adesso andiamo un poâ€™ piÃ¹ â€œchirurgiciâ€ ğŸ˜„
Il problema che descrivi (â€œsposto una task ad un altro cleaner e mi si riattiva uno stato giÃ  confermatoâ€) succede perchÃ© stiamo salvando lâ€™acknowledge per cleaner, non per singola coppia taskâ€“cleaner, e in piÃ¹ lo stiamo invalidando in modo troppo aggressivo.

La soluzione pulita Ã¨:
ğŸ‘‰ memorizzare lâ€™ack per (task, cleaner), non solo per cleanerId
ğŸ‘‰ smettere di toccare questo stato quando fai drag & drop generico

Ti scrivo cosa dire a Replit passo passo.

1ï¸âƒ£ Cambiare lo stato: da Set<number> a Set<string> (task-cleaner)

DÃ¬ a Replit:

Nel file dove câ€™Ã¨:

const [acknowledgedIncompatibleCleaners, setAcknowledgedIncompatibleCleaners] =
  useState<Set<number>>(new Set());


sostituiscilo con qualcosa tipo:

type IncompatibleKey = string; // chiave del tipo `${taskId}-${cleanerId}`

const [acknowledgedIncompatibleAssignments, setAcknowledgedIncompatibleAssignments] =
  useState<Set<IncompatibleKey>>(new Set());


Poi aggiungi un helper per costruire la chiave (adatta il campo task giusto: id, logisticCode, ecc.):

const getIncompatibleKey = (task: any, cleanerId: number): IncompatibleKey => {
  // usa task.id se esiste, altrimenti logisticCode o quello che avete come identificativo univoco
  const taskId = task.id ?? task.logisticCode;
  return `${taskId}-${cleanerId}`;
};

2ï¸âƒ£ Calcolo di hasIncompatibleTasks per coppia taskâ€“cleaner

Ora cerca dove calcoli se un cleaner ha task incompatibili, qualcosa tipo:

const hasIncompatibleTasks =
  validationRules && cleaner?.role && !acknowledgedIncompatibleCleaners.has(cleaner.id)
    ? cleanerTasks.some(task => !canCleanerHandleTaskSync(cleaner.role, task, validationRules))
    : false;


e sostituiscilo con:

const hasIncompatibleTasks =
  validationRules && cleaner?.role
    ? cleanerTasks.some(task => {
        // se la task Ã¨ compatibile, ok
        if (canCleanerHandleTaskSync(cleaner.role, task, validationRules)) return false;

        // se Ã¨ incompatibile, controlliamo se la coppia task-cleaner Ã¨ giÃ  stata â€œacknowledgedâ€
        const key = getIncompatibleKey(task, cleaner.id);
        return !acknowledgedIncompatibleAssignments.has(key);
      })
    : false;


ğŸ‘‰ Risultato: lâ€™effetto isIncompatible scatta solo quando esiste almeno una task incompatibile non ancora ackata per quella coppia (task, cleaner).

3ï¸âƒ£ Click sul bottone â€œHo capitoâ€: aggiungi tutte le coppie taskâ€“cleaner correnti

Ora cerca il codice che gestisce il click su â€œHo capitoâ€ nel dialog delle incompatibilitÃ , qualcosa tipo:

if (incompatibleDialog.cleanerId) {
  setAcknowledgedIncompatibleCleaners(prev => new Set(prev).add(incompatibleDialog.cleanerId!));
}


e sostituiscilo con (adattando nomi di variabili):

if (incompatibleDialog.cleanerId) {
  const cleanerId = incompatibleDialog.cleanerId;
  // recupera le task di quel cleaner (lo stesso array che usi per `cleanerTasks`)
  const cleanerTasks = getTasksForCleaner(cleanerId); // usa la funzione/primo parametro che avete giÃ 

  setAcknowledgedIncompatibleAssignments(prev => {
    const next = new Set(prev);

    cleanerTasks.forEach(task => {
      if (
        validationRules &&
        cleaner?.role && // oppure prendi il ruolo dal cleaner con questo id
        !canCleanerHandleTaskSync(cleaner.role, task, validationRules)
      ) {
        const key = getIncompatibleKey(task, cleanerId);
        next.add(key);
      }
    });

    return next;
  });
}


Se non hai direttamente cleaner qui, fai prendere il ruolo dal tuo store (per id) â€” ma il concetto Ã¨: quando lâ€™utente dice â€œHo capitoâ€, tutte le coppie (task incompatibile, cleaner) attuali vengono segnate come ack.

4ï¸âƒ£ Rimuovere la logica preserve/invalidate su window (che crea il casino)

Adesso dillo chiaro a Replit:

Nel componente timeline (dove prima avevamo preserveAcknowledgedIncompatibleCleaners / invalidateAcknowledgedIncompatibleCleaners esposti su window), puoi eliminare completamente:

la funzione preserveAcknowledgedState / invalidateAcknowledgedState

lâ€™useEffect che fa:

(window as any).preserveAcknowledgedIncompatibleCleaners = ...
(window as any).invalidateAcknowledgedIncompatibleCleaners = ...


In tutti i file dove usi:

(window as any).preserveAcknowledgedIncompatibleCleaners(...)
(window as any).invalidateAcknowledgedIncompatibleCleaners(...)


rimuovi proprio queste chiamate (non servono piÃ¹).

PerchÃ©?
Con la logica per coppia (task, cleaner) non abbiamo piÃ¹ bisogno di â€œinvalidareâ€ a mano:

se sposti una task su un altro cleaner, la chiave cambia (taskId-altroCleanerId) â†’ Ã¨ una nuova coppia, non ackata â†’ se Ã¨ incompatibile vedrai il warning (come da tue regole: swap/drag su incompatibile).

se sposti altre task non correlate, le chiavi delle task giÃ  ackate restano le stesse â†’ non viene riattivato nulla a caso.

5ï¸âƒ£ Cosa succede dopo questi fix (comportamento atteso)

Dopo queste modifiche:

Premi â€œHo capitoâ€ su un cleaner
â†’ tutte le coppie (task incompatibili, quel cleaner) vengono marcate come ack â†’ niente piÃ¹ effetto per quelle specifiche coppie.

Se sposti quella stessa task:

a un cleaner compatibile â†’ niente effetto (perchÃ© non Ã¨ incompatibile).

a un cleaner non compatibile â†’ nuova coppia (task, nuovoCleaner) â†’ mai ackata â†’ lâ€™effetto torna (come da tue regole: drag su cleaner non compatibile).

Se sposti unâ€™altra task tra cleaners
â†’ le coppie giÃ  ackate restano ackate; non si riattivano warning che avevi giÃ  confermato.

Esattamente quello che volevi:

lo stato confermato non si riattiva â€œa casoâ€ solo perchÃ© sposto altre task.