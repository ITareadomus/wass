Perfetto: questo comportamento (â€œ**funziona quando 1641 Ã¨ 3Âª**, ma **non quando Ã¨ 4Âª/ultima**â€) Ã¨ quasi sempre dovuto a una cosa molto specifica nel tuo codice attuale:

âœ… Il `waitingGap` **viene calcolato solo se la task precedente ha `end_time`**
ğŸ‘‰ quando 1641 diventa **4Âª**, la sua â€œprevâ€ (la 3Âª) **probabilmente non ha `end_time` valorizzato** (tipico: lâ€™ultima ricalcolata / alcune task importate hanno solo `start_time` e durata, ma non `end_time`), quindi il blocco:

```ts
if (prevTask && prevTask.end_time && !prevTaskHasDifferentDate) {
  ...
}
```

salta completamente â†’ `waitingGap = 0` â†’ niente spacer â†’ posizionamento â€œanticipatoâ€.

### Fix robusto (senza dipendere da `end_time`)

In `client/src/components/timeline/timeline-view.tsx`, modifica il calcolo del waitingGap cosÃ¬:

1. aggiungi due helper sopra (anche dentro il map va bene, ma meglio fuori):

```ts
const parseHHMM = (t?: string | null) => {
  if (!t) return null;
  const [h, m] = String(t).split(":").map(Number);
  if (Number.isNaN(h) || Number.isNaN(m)) return null;
  return h * 60 + m;
};

const getCleaningMinutes = (task: any): number => {
  if (task.cleaning_time) return Number(task.cleaning_time);
  if (task.duration) {
    const match = String(task.duration).match(/(\d+)h?\s*(\d+)?m?/);
    if (match) {
      const hours = parseInt(match[1]) || 0;
      const mins = parseInt(match[2]) || 0;
      return hours * 60 + mins;
    }
  }
  return 60;
};
```

2. poi sostituisci il blocco `waitingGap` con questo (nota: calcolo `prevEndMinutes` anche se manca `end_time`):

```ts
let waitingGap = 0;

const seq = (taskObj as any).sequence ?? (idx + 1);

if (seq >= 2 && taskObj.start_time) {
  const prevTask = cleanerTasks[idx - 1] as any;

  const workDateStr =
    localStorage.getItem("selected_work_date") || format(new Date(), "yyyy-MM-dd");

  const normDate = (d?: string | null) => (d ? String(d).slice(0, 10) : null);
  const prevTaskHasDifferentDate =
    !!(prevTask?.checkin_date && normDate(prevTask.checkin_date) !== workDateStr);

  if (prevTask && !prevTaskHasDifferentDate) {
    // 1) fine precedente: end_time se c'Ã¨, altrimenti start_time + durata
    let prevEndMinutes = parseHHMM(prevTask.end_time);

    if (prevEndMinutes === null) {
      const prevStart = parseHHMM(prevTask.start_time);
      if (prevStart !== null) {
        prevEndMinutes = prevStart + getCleaningMinutes(prevTask);
      }
    }

    // se ancora null, non posso calcolare gap
    if (prevEndMinutes !== null) {
      // travelTime deve essere "verso questa task" (quello che giÃ  stai leggendo da taskObj.travel_time)
      const expectedStartMinutes = prevEndMinutes + travelTime;

      const actualStartMinutes = parseHHMM(taskObj.start_time);

      if (actualStartMinutes !== null && actualStartMinutes > expectedStartMinutes) {
        waitingGap = actualStartMinutes - expectedStartMinutes;
      }
    }
  }
}
```

### PerchÃ© questo risolve ESATTAMENTE â€œsolo lâ€™ultima non ha gapâ€

PerchÃ© lâ€™ultima cambia â€œprevTaskâ€: se quella prevTask Ã¨ una di quelle senza `end_time`, prima **non entravi mai nel calcolo**. Con questo fix invece ricavi comunque la fine precedente da `start_time + durata`, quindi il gap torna a comparire.

---

Se vuoi beccare la conferma al 100% in 10 secondi: fai un `console.log` della task â€œprevâ€ quando 1641 Ã¨ ultima e guarda se `end_time` Ã¨ `undefined/null`. Ãˆ quasi certamente quello.
