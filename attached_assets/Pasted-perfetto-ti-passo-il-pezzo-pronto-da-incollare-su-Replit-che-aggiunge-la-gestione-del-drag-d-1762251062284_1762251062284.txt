perfetto â€” ti passo il pezzo **pronto da incollare su Replit** che aggiunge la gestione del **drag da container (early/high/low) â†’ timeline**.
Incollalo dentro `client/src/pages/generate-assignments.tsx`, nella funzione `onDragEnd` **subito dopo** aver calcolato `source`, `destination`, ecc. (prima dei casi â€œcontainers â†” containersâ€ e â€œtimeline â†” timelineâ€).

> ðŸ”§ Se non hai giÃ  queste helper (`parseCleanerId`, `addAssignmentToTimeline`), incollale anche: le trovi sotto al blocco principale.

---

### ðŸ” Patch da incollare (blocchetto per `onDragEnd`)

```ts
// ðŸ‘‰ PATCH: gestione drag da container (early/high/low) â†’ timeline (cleaner row)
if (result?.destination) {
  const { source, destination, draggableId } = result;

  // Utility locali per capire da dove a dove stiamo trascinando
  const fromCleanerId = parseCleanerId(source.droppableId);       // es: timeline:cleaner:123 â†’ "123"
  const toCleanerId   = parseCleanerId(destination.droppableId);  // idem
  const fromContainer = parseContainerKey(source.droppableId);    // es: container:early â†’ "early"
  const toContainer   = parseContainerKey(destination.droppableId);

  // âœ… NUOVO CASO: da container (early/high/low) â†’ timeline di un cleaner
  if (!fromCleanerId && !!fromContainer && !!toCleanerId && !toContainer) {
    try {
      const dropIndex = destination.index ?? 0;
      await addAssignmentToTimeline(draggableId, toCleanerId, dropIndex);

      // Risincronizza UI/Store: usa il tuo metodo centralizzato se esiste
      if ((window as any).reloadAllTasks) {
        await (window as any).reloadAllTasks(true);
      } else if (typeof refetch === "function") {
        await refetch(); // in caso tu stia usando react-query o simili
      }
    } catch (err) {
      console.error("Errore nel salvataggio in timeline:", err);
      // usa il tuo sistema di toast/notifiche se presente
      if (typeof toast === "function") {
        toast({
          title: "Errore",
          description: "Impossibile assegnare la task alla timeline.",
          variant: "destructive",
        });
      }
    }
    return; // importantissimo: eviti che il resto della onDragEnd sovrascriva lo stato
  }
}
```

---

### ðŸ§© Helper da includere se mancanti

> Se nel tuo file non esistono giÃ , aggiungi queste funzioni (puoi metterle in alto o sotto alla `onDragEnd`).

```ts
// Estrae l'ID cleaner da un droppableId tipo "timeline:cleaner:<id>"
function parseCleanerId(droppableId: string | undefined | null): string | null {
  if (!droppableId) return null;
  const prefix = "timeline:cleaner:";
  if (!droppableId.startsWith(prefix)) return null;
  return droppableId.slice(prefix.length);
}

// Estrae la chiave container da un droppableId tipo "container:early|high|low"
function parseContainerKey(droppableId: string | undefined | null): "early" | "high" | "low" | null {
  if (!droppableId) return null;
  const prefix = "container:";
  if (!droppableId.startsWith(prefix)) return null;
  const key = droppableId.slice(prefix.length);
  if (key === "early" || key === "high" || key === "low") return key;
  return null;
}

// Chiama l'API di salvataggio assegnazione in timeline (server side rimuove anche dal container)
async function addAssignmentToTimeline(taskId: string, cleanerId: string, index: number) {
  const res = await fetch("/api/save-timeline-assignment", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ taskId, cleanerId, index }),
  });
  if (!res.ok) {
    const t = await res.text().catch(() => "");
    throw new Error(`save-timeline-assignment failed: ${res.status} ${t}`);
  }
  return res.json().catch(() => ({}));
}
```

---

### Dove incollare esattamente

1. Apri `client/src/pages/generate-assignments.tsx`.
2. Cerca la funzione `onDragEnd`.
3. Incolla il **blocchetto patch** allâ€™inizio della logica (subito dopo i `const { source, destination, draggableId } = result;` e prima di altri `if` che gestiscono spostamenti tra container o timeline).
4. Se non presenti, incolla anche le **helper** qui sopra (una sola volta).
5. Salva, builda/riavvia. Trascinando una task da **early/high/low** alla riga del **cleaner**, ora dovresti vederla nella **timeline**.

Se preferisci, posso fornirti la **versione completa** della `onDragEnd` con tutti i rami ordinati (containersâ†”containers, timelineâ†”timeline, containerâ†’timeline) giÃ  integrati.
