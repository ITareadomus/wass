Implementazione FASE 3 (Scheduling + vincoli temporali) in shadow mode

Devi implementare FASE 3 nel progetto Node/TypeScript esistente (TaskFlowMaster). La FASE 1 e FASE 2 sono già implementate e lavorano in shadow mode scrivendo solo su optimizer.*. Ora devi aggiungere FASE 3 per generare una timeline valida per ogni cleaner, rispettando travel time e vincoli checkout/checkin, senza toccare le assegnazioni di produzione.

Vincolo fondamentale (NON negoziabile)

Leggi da tabelle prod (tasks/cleaners/etc.) solo in read-only

Scrivi solo su schema optimizer:

optimizer.optimizer_decision (log spiegabile)

optimizer.optimizer_assignment (output scheduling definitivo per UI)

optimizer.optimizer_unassigned (solo task davvero impossibili)

Non creare/modificare assegnazioni reali in produzione.

Input

Endpoint: POST /api/optimizer/run-phase3

Body:

{ "date": "YYYY-MM-DD", "runId": "..."? }


runId è opzionale: se non passato, usa l’ultima optimizer.optimizer_run per quella data.

FASE 3 deve usare solo i cleaners selezionati dall’utente tramite daily_selected_cleaners (stesso criterio già applicato in FASE 2).

Dati da caricare (read-only)
1) Selected cleaners

Usa la stessa logica della FASE 2:

leggi daily_selected_cleaners per la data (array di cleaner_id)

carica SOLO cleaners disponibili/attivi che rientrano in quell’elenco

se selected_cleaners è vuoto/null → FASE 3 non schedula nulla, mette tutto in unassigned candidate con reason NO_SELECTED_CLEANERS (decision log) e termina.

2) Task del giorno

Carica dal DB le task che stanno nel perimetro della run (stessa sorgente usata in FASE 1 / FASE 2, tipicamente daily_containers).
Ti servono almeno:

task_id

lat, lng

cleaning_time_minutes (o equivalente)

checkout_time (earliest start) se esiste

checkin_time (latest end) se esiste

Gestisci i formati orari HH:MM e HH:MM:SS.

3) Output FASE 2: gruppi assegnati per cleaner

Recupera da optimizer.optimizer_decision:

phase = 2 AND event_type = 'PHASE2_GROUP_ASSIGNED' AND run_id = $runId
Il payload contiene:

cleanerId (o cleaner_id)

lista task_ids del gruppo (es. taskIds, tasks, ecc.)

Costruisci una struttura:

cleaner_id -> list of groups, dove ogni group è task_ids[] (2–4 o single)

Travel time

Riusa la funzione travel già fatta in FASE 1.5:

server/services/optimizer/travelTime.ts

getTravelMinutes(from, to): Promise<number>
Deve usare cache (optimizer.travel_time_cache) e fallback stimato se manca API key.

In FASE 3 il travel time è parte fondamentale del calcolo timeline.

Algoritmo FASE 3 (Versione 1: robusta e semplice)

Per ogni cleaner (solo quelli selezionati) che ha gruppi assegnati dalla FASE 2:

A) Scheduling per gruppi (blocco per blocco)

Processa i gruppi in un ordine stabile:

usa l’ordine dei gruppi così come li hai letti dalla FASE 2 (o ordina per score se nel payload c’è groupScore).

Per ogni gruppo:

se size = 1 → schedula direttamente se rispetta time window

se size 2–4 → prova tutte le permutazioni (max 24) e scegli la migliore fattibile

B) Simulazione timeline per una sequenza di task

Implementa una funzione:
simulateSequence(cleaner, tasksSeq, startTime): { ok, scheduleRows, totalTravel, totalWait, endTime, failReason }

Regole:

current = startTime (startTime = cleaner.start_time sul workDate; se null usa 09:00)

per ogni task in sequence:

travelMin = travel(prevTask -> task) (per prima task travel=0, oppure se hai lastPos usa quello; in v1 travel=0 per prima va bene)

arrival = current + travelMin

earliestStart = max(arrival, checkout_time se presente)

wait = earliestStart - arrival (se >0)

end = earliestStart + cleaning_time_minutes

se checkin_time presente e end > checkin_time → FAIL (TIME_WINDOW_IMPOSSIBLE)

salva riga schedule con:

sequence index

task_id

start_time, end_time

travel_minutes_from_prev

wait_minutes (se vuoi)

current = end

Se tutta la sequenza passa: OK.

C) Scelta migliore permutazione

Tra le permutazioni fattibili scegli:

endTime più piccolo

a parità: totalWait minore

a parità: totalTravel minore

D) Se nessuna permutazione funziona

Se gruppo size > 1:

rimuovi 1 task e riprova (fino a quando resta single)

la task rimossa va in optimizer.optimizer_unassigned con reason TIME_WINDOW_IMPOSSIBLE (o GROUP_SCHEDULING_FAILED) e dettagli diagnostici

logga decision PHASE3_TASK_DROPPED_TIME

Se gruppo single non schedulabile:

va in optimizer.optimizer_unassigned con reason TIME_WINDOW_IMPOSSIBLE

Scritture su optimizer.*
1) optimizer.optimizer_assignment (output finale)

Per ogni task schedulata (quindi solo quelle che hanno una timeline valida) inserisci una riga con almeno:

run_id

work_date

cleaner_id

task_id

sequence

start_time (timestamp o time coerente con schema)

end_time

travel_minutes_from_prev

metadata json (opzionale: wait_minutes, perm_index, ecc.)

Non scrivere nulla nelle tabelle prod.

2) optimizer.optimizer_unassigned

Per le task impossibili:

run_id, work_date, task_id

reason_code:

TIME_WINDOW_IMPOSSIBLE

NO_SELECTED_CLEANERS

MISSING_TIME_DATA (se manca cleaning_time o lat/lng o time window e decidi di bloccarla)

details json: checkout/checkin/cleaning_time, tentativi permutazioni, ecc.

3) optimizer.optimizer_decision (fase=3)

Inserisci eventi (minimo indispensabile):

PHASE3_GROUP_SCHEDULED (quando un gruppo viene schedulato con una permutazione)

payload: cleaner_id, task_ids, chosen_order, total_travel, total_wait, end_time

PHASE3_TASK_DROPPED_TIME (quando droppi una task da un gruppo)

payload: cleaner_id, dropped_task_id, reason, remaining_tasks

PHASE3_TASK_UNASSIGNED_FINAL (quando una task finisce in optimizer_unassigned)

payload: task_id, reason_code, details

Eventi devono avere run_id, phase=3.

Endpoint output

POST /api/optimizer/run-phase3 deve restituire:

{
  "runId": "...",
  "cleanersProcessed": 7,
  "tasksScheduled": 15,
  "tasksUnassigned": 0,
  "assignmentsInserted": 15,
  "unassignedInserted": 0,
  "decisionsInserted": 20
}

Struttura codice richiesta

Crea o aggiorna questi file (coerente con pattern FASE1/FASE2):

server/services/optimizer/phase3.ts

simulateSequence

permute helper (2–4)

scheduleGroupsForCleaner

server/services/optimizer/runPhase3.ts

load selected cleaners

load tasks

load phase2 group assignments from optimizer_decision

call phase3

persist optimizer_assignment / optimizer_unassigned / optimizer_decision

update optimizer_run.summary e status

server/routes/optimizer.ts (o file routing equivalente)

aggiungi route POST /api/optimizer/run-phase3

Test / sanity check

Aggiungi almeno uno script o test minimo che:

lancia run-phase3 su una data con runId

verifica che in optimizer.optimizer_assignment siano state scritte righe per la run

verifica che non ci siano scritture su tabelle prod.

Note importanti

Usa il timezone coerente col progetto (Europa/Rome).

Non fare OCR o servizi esterni oltre Google Distance Matrix già usato per travelTime.

Mantieni le query parametrizzate.

Mantieni shadow mode: nessun aggiornamento su assegnazioni attuali.