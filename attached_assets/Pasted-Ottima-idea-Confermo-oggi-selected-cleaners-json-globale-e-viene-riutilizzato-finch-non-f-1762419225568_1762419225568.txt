Ottima idea. Confermo: oggi **`selected_cleaners.json` è globale** e viene riutilizzato finché non fai una nuova convocazione; quindi quando passi a una giornata “nuova” il roster resta sporco.
La soluzione pulita è renderlo **per-data** e salvarlo/ricaricarlo **insieme** alle assegnazioni del giorno.

Qui sotto ti lascio le patch “drop-in” su `server/routes.ts` (Replit) per:

1. **/api/confirm-assignments** → salva anche `selected_cleaners_*.json` nello stesso bucket del file `assignments_*.json`
2. **/api/load-saved-assignments** → ricarica (se esiste) `selected_cleaners_*.json` riscrivendo `client/public/data/cleaners/selected_cleaners.json`
3. **/api/reset-timeline-assignments** → quando resetti la giornata, inizializza anche `selected_cleaners.json` con struttura vuota e `metadata.date = YYYY-MM-DD`

> Non tocchiamo il frontend: continuerà a leggere `client/public/data/cleaners/selected_cleaners.json`, che ora sarà *sempre coerente con la data*.

---

# 1) Salva i cleaner selezionati per data (insieme alle assegnazioni)

**In `server/routes.ts`, nell’endpoint `/api/confirm-assignments`** (lo trovi già), **subito dopo** aver calcolato `filename = assignments_DDMMYY.json` aggiungi questo blocco per salvare anche i cleaner:

```ts
// === NEW: salva anche i selected_cleaners per la stessa data ===
const selectedCleanersPath = path.join(
  process.cwd(),
  'client/public/data/cleaners/selected_cleaners.json'
);

// leggi i cleaners selezionati correnti (se non esiste, crea vuoto)
let selectedCleanersData: any;
try {
  const scRaw = await fs.readFile(selectedCleanersPath, 'utf8');
  selectedCleanersData = JSON.parse(scRaw);
} catch {
  selectedCleanersData = { cleaners: [], total_selected: 0 };
}

// inject metadata.date per robustezza
selectedCleanersData.metadata = selectedCleanersData.metadata || {};
selectedCleanersData.metadata.date = workDate;
selectedCleanersData.metadata.saved_at = new Date().toISOString();

// nome file: selected_cleaners_DDMMYY.json
const scFilename = `selected_cleaners_${day}${month}${year}.json`;

const scJson = JSON.stringify(selectedCleanersData, null, 2);
const scResult = await client.uploadFromText(scFilename, scJson, {
  bucket: 'wass_assignments'
});
if (!scResult.ok) {
  throw new Error(scResult.error || 'Errore nel salvataggio dei selected_cleaners');
}
console.log(`✅ Selected cleaners salvati in Object Storage: ${scFilename}`);
// === END NEW ===
```

> Così quando confermi le assegnazioni, il bucket contiene **coppia**:
> `assignments_DDMMYY.json` + `selected_cleaners_DDMMYY.json`.

---

# 2) Carica i cleaner selezionati per data insieme alle assegnazioni

**Nell’endpoint `/api/load-saved-assignments`**, dopo aver calcolato:

```ts
const filename = `assignments_${day}${month}${year}.json`;
```

aggiungi la parte che prova a scaricare anche i cleaner e li riscrive in locale:

```ts
// === NEW: scarica e ripristina selected_cleaners per la stessa data ===
const scFilename = `selected_cleaners_${day}${month}${year}.json`;
try {
  const scResult = await client.downloadAsText(scFilename, { bucket: 'wass_assignments' });
  if (scResult.ok) {
    const scData = JSON.parse(scResult.value);
    const selectedCleanersPath = path.join(
      process.cwd(),
      'client/public/data/cleaners/selected_cleaners.json'
    );

    // update metadata coerente
    scData.metadata = scData.metadata || {};
    scData.metadata.date = workDate;
    scData.metadata.loaded_at = new Date().toISOString();

    const tmpScPath = `${selectedCleanersPath}.tmp`;
    await fs.writeFile(tmpScPath, JSON.stringify(scData, null, 2));
    await fs.rename(tmpScPath, selectedCleanersPath);

    console.log(`✅ Selected cleaners ripristinati da Object Storage: ${scFilename}`);
  } else {
    console.log(`ℹ️ Nessun selected_cleaners salvato per ${workDate} (${scFilename})`);
  }
} catch (e) {
  console.warn(`⚠️ Impossibile caricare ${scFilename}:`, e);
}
// === END NEW ===
```

> Effetto: quando carichi le assegnazioni del **4/11**, in locale viene scritto anche il `selected_cleaners.json` coerente con quel giorno; la timeline vede **tutti** i cleaner corretti.

---

# 3) Reset di giornata: azzera anche `selected_cleaners.json` con metadata.date

**Nell’endpoint `/api/reset-timeline-assignments`** (già presente), dopo aver creato/salvato la nuova `timeline.json`, **aggiungi**:

```ts
// === NEW: resetta anche selected_cleaners.json per la nuova data ===
try {
  const selectedCleanersPath = path.join(
    process.cwd(),
    'client/public/data/cleaners/selected_cleaners.json'
  );

  const emptySelected = {
    cleaners: [],
    total_selected: 0,
    metadata: { date: workDate, reset_at: new Date().toISOString() }
  };

  const tmpScPath = `${selectedCleanersPath}.tmp`;
  await fs.writeFile(tmpScPath, JSON.stringify(emptySelected, null, 2));
  await fs.rename(tmpScPath, selectedCleanersPath);

  console.log(`✅ selected_cleaners.json resettato per ${workDate}`);
} catch (e) {
  console.warn('⚠️ Impossibile resettare selected_cleaners.json:', e);
}
// === END NEW ===
```

> Così quando passi a una giornata nuova senza convocazioni, il **roster è vuoto per definizione** (come volevi) e il file locale riporta la data corrente. Quando confermi/ricarichi, passerai sempre per la versione *per-data*.

---

## Note operative / compatibilità

* **Backward-compatible**: aggiungiamo un campo `metadata` in `selected_cleaners.json`, ma il resto del codice legge `cleaners` e `total_selected` → non si rompe nulla.
* Non serve toccare il frontend: continua a leggere/scrivere il file locale, che ora viene **sincronizzato per data** dal server.
* Se vuoi, puoi anche mostrare la data corrente del roster leggendo `selected_cleaners.json.metadata.date` (comodo per debug).

---

## Bonus (opzionale): endpoint rapido per “imposta roster vuoto per data”

Se vuoi un tasto “Nuova giornata”, puoi creare un endpoint semplice che richiama solo la parte NEW del reset di cui sopra (senza rigenerare containers). Ma con le modifiche 1–3 di solito non serve.

---

Se vuoi, copio/incastro io le patch esatte nel punto giusto del file: incolla qui ~20 righe prima/dopo dei tre endpoint e te le monto 1:1.
