Dove nasce il problema (trovato nel codice)
1) assign_eo.py assegna sempre sequence = idx + 1 alle EO

File: client/public/scripts/assign_eo.py
Funzione: build_output(...)
Qui le task EO vengono create con:

sequence: idx + 1 (riparte sempre da 1)

travel_time calcolato solo dentro la route EO

ğŸ‘‰ Se tu hai giÃ  task in timeline (perchÃ© le hai trascinate manualmente), quando poi lanci â€œAssign Early Outâ€, lo script fa merge e ti ritrovi due task con sequence=1 (una manuale + la prima EO).

2) Quando fa merge non rinumera mai le sequence

File: client/public/scripts/assign_eo.py
Dopo il merge delle task nel blocco:

# Aggiungi le nuove assegnazioni EO organizzate per cleaner
...
cleaner_entry_existing["tasks"].extend(new_tasks)
...
# Solo ordinamento per start_time (senza ricalcolo)
tasks.sort(key=lambda t: t.get("start_time") or "00:00")


ğŸ‘‰ Qui ordina, ma non:

rinumera sequence

ricalcola travel_time tra task manuali ed EO (perchÃ© lâ€™ordine Ã¨ cambiato / perchÃ© ci sono doppie sequence)

Risultato: duplicate sequence=1 e travel time â€œnon calcolatoâ€ (perchÃ© la UI e/o altre logiche si basano sulla sequence).

Scaletta di modifiche da fare (mirata, con file/zone)
A) Fix principale: dopo il merge EO â†’ rinumerare sequence e sistemare travel_time

File: client/public/scripts/assign_eo.py
Punto: subito dopo il sort per start_time (nel main, dopo il merge)

Dopo:

tasks.sort(key=lambda t: t.get("start_time") or "00:00")


aggiungi una routine per ogni entry:

sequence = i + 1 per tutte le task del cleaner (non solo EO)

followup = i > 0

travel_time ricalcolato come differenza tra start_time corrente e end_time precedente:

travel_time = max(0, start_min - prev_end_min)

se manca start/end, lascia invariato o fallback a 0

Questo da solo elimina:

sequence duplicate

travel_time â€œnon calcolatoâ€ perchÃ© la prima EO non Ã¨ piÃ¹ â€œsequence=1â€ se non deve esserlo

Nota: questo approccio non richiede API map/distance: usa i tempi giÃ  presenti (start/end) e li rende coerenti.

B) Rendere lâ€™EO â€œappend-safeâ€: non ripartire da 1 quando esistono task nel cleaner

File: client/public/scripts/assign_eo.py
Punto: build_output(...)

Prima di creare tasks_list, calcola base_seq leggendo la timeline esistente per quel cleaner:

base_seq = max(sequence esistenti) oppure 0

Poi sostituisci:

sequence: idx + 1
con:

sequence: base_seq + idx + 1
e followup: (base_seq + idx) > 0

Anche se poi fai la rinumerazione globale (punto A), questo evita stati intermedi â€œsporchiâ€ e rende il merge piÃ¹ robusto.

C) Guard-rail server-side: valida che non esistano sequence duplicate prima di salvare

File: server/routes.ts
Punto consigliato: endpoint /api/assign-early-out-to-timeline (dopo che lo script salva via API) oppure dentro workspaceFiles.saveTimeline(...) se hai un punto centrale.

Aggiungi una normalizzazione/validazione:

per ogni cleaner, se trova sequence duplicate o buchi:

sort per start_time

rinumera sequence 1..N

ricalcola followup

(opzionale) ricalcola travel_time come in A

Questo ti protegge anche da dati giÃ  â€œsporchiâ€ salvati in passato.

D) Bug collaterale (da sistemare, ma non Ã¨ la causa del doppio â€œ1â€)

File: client/src/pages/generate-assignments.tsx
Funzione: recomputeCleanerTimes(...)

Qui assegni:

sequence: idx,


Ã¨ 0-based. Se questa finisce mai salvata o usata per logiche, crea incoerenze.

Correzione:

sequence: idx + 1

(Questo Ã¨ piÃ¹ â€œigieneâ€: il vero duplicato â€œsequence=1â€ ti arriva dallâ€™EO merge, ma questa Ã¨ una mina nascosta.)