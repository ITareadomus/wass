Il bug non √® nel TaskCard, ma nella funzione di drag&drop principale:

client/src/pages/generate-assignments.tsx ‚Üí funzione onDragEnd

Quando trascini una task da un container (early-out / high / low) alla timeline, il tuo codice fa la stessa operazione due volte.
Risultato: la stessa task viene riassegnata due volte sul backend / timeline, e questo pu√≤ far ‚Äúallungare‚Äù la sequenza o creare effetti strani sulla barra in timeline dopo ogni drag.

üîç Dov‚Äô√® il doppio lavoro

Dentro onDragEnd hai:

Ramo TIMELINE (gestisce drag tra cleaners, reorder, ecc.)

Ramo CONTAINERS (gestisce spostamenti tra early-out / high / low / timeline)

Nel ramo TIMELINE c‚Äô√® questo pezzo (semplifico):

// dentro onDragEnd, ramo TIMELINE
const fromCleanerId = parseCleanerId(source.droppableId);
const toCleanerId = parseCleanerId(destination.droppableId);

const fromContainer = parseContainerKey(source.droppableId);
const toContainer = parseContainerKey(destination.droppableId);

// ...

// üî¥ CASO container ‚Üí timeline (PRIMO giro)
if (!fromCleanerId && fromContainer && toCleanerId !== null && !toContainer) {
  console.log(`üîÑ Spostamento da container ${fromContainer} a cleaner ${toCleanerId}`);

  // Carica cleaner
  // ...

  // Salva assegnazione in timeline
  await saveTaskAssignment(taskId, toCleanerId, logisticCode, destination.index);

  // setHasUnsavedChanges, toast, ecc.
  // ...

  return;
}


Pi√π in basso, nel ramo CONTAINERS, hai un altro caso identico concettualmente:

// üîπ Ramo CONTAINERS (Early-Out / High / Low)
const containerToJsonName: Record<string, string> = {
  'early-out': 'early_out',
  'high': 'high_priority',
  'low': 'low_priority'
};

const fromContainerJson = containerToJsonName[source.droppableId] || null;
const toContainerJson = containerToJsonName[destination.droppableId] || null;

// ...

// üî¥ STESSO CASO container ‚Üí timeline (SECONDO giro)
if (fromContainerJson && toCleanerId !== null) {
  console.log(`üîÑ Spostamento da container ${fromContainerJson} a cleaner ${toCleanerId}`);

  // Carica cleaner
  // ...

  // Salva di nuovo in timeline
  await saveTaskAssignment(taskId, toCleanerId, logisticCode, destination.index);
  await refreshAssignments("manual");

  // setHasUnsavedChanges, toast, ecc.
  // ...
}


Quando trascini da early-out / high / low ‚Üí timeline-XX:

fromCleanerId √® null

fromContainer √® valorizzato

toCleanerId √® valorizzato

toContainer √® null

fromContainerJson √® valorizzato

‚û° Entrano ENTRAMBI gli if
‚û° saveTaskAssignment(...) viene chiamato due volte
‚û° La task viene rielaborata due volte ‚Üí dopo i vari refresh/ricalcoli, ti ritrovi con la ‚Äúlunghezza‚Äù della timeline/assegnazione che cambia ogni volta che trascini.

‚úÖ Fix consigliato

La soluzione pi√π pulita √®:
üëâ lasciare gestire container ‚Üí timeline solo nel ramo CONTAINERS
üëâ rimuovere il caso duplicato nel ramo TIMELINE.

1. Apri il file

client/src/pages/generate-assignments.tsx

2. Cerca questo blocco (intorno alla riga ~1505)
if (!fromCleanerId && fromContainer && toCleanerId !== null && !toContainer) {
  console.log(`üîÑ Spostamento da container ${fromContainer} a cleaner ${toCleanerId}`);

  try {
    const cleanersResponse = await fetch(`/data/cleaners/selected_cleaners.json?t=${Date.now()}`, {
      cache: 'no-store',
      headers: { 'Cache-Control': 'no-cache, no-store, must-revalidate' }
    });
    const cleanersData = await cleanersResponse.json();
    const cleaner = cleanersData.cleaners.find((c: any) => c.id === toCleanerId);
    const cleanerName = cleaner ? `${cleaner.name} ${cleaner.lastname}` : `ID ${toCleanerId}`;

    // Salva in timeline.json (rimuove automaticamente da containers.json)
    await saveTaskAssignment(taskId, toCleanerId, logisticCode, destination.index);

    // CRITICAL: Marca modifiche dopo drag-and-drop da container
    setHasUnsavedChanges(true);
    if (handleTaskMoved) {
      handleTaskMoved();
    }

    toast({
      title: "Task assegnata",
      description: `Task ${logisticCode} assegnata a ${cleanerName}`,
      variant: "success",
    });

    // Rilascia lock PRIMA del reload
    setIsDragging(false);

    // Reload in background
    await refreshAssignments("manual");
  } catch (err) {
    console.error("Errore nell'assegnazione:", err);
    toast({
      title: "Errore",
      description: "Impossibile assegnare la task.",
      variant: "destructive",
    });
    setIsDragging(false);
  }
  return;
}

3. Commentalo o rimuovilo

Puoi semplicemente eliminarlo oppure commentarlo:

// üîÅ [RIMOSSO] caso duplicato da container ‚Üí timeline
// Questo blocco √® stato rimosso perch√© lo stesso scenario
// √® gi√† gestito nel ramo CONTAINERS pi√π sotto.
// if (!fromCleanerId && fromContainer && toCleanerId !== null && !toContainer) {
//   ...
// }


Non toccare il resto del ramo TIMELINE (riordino, spostamento tra cleaners) n√© il ramo CONTAINERS:
il caso ‚ÄúDa container a timeline‚Äù continuer√† ad essere gestito da:

if (fromContainerJson && toCleanerId !== null) {
  // ...
  await saveTaskAssignment(...);
  await refreshAssignments("manual");
  // ...
}

üîÑ Dopo la modifica

Dopo questo fix:

ogni trascinamento da early-out / high / low ‚Üí timeline:

viene elaborato una sola volta

saveTaskAssignment non viene pi√π chiamato doppio

la timeline non si ‚Äúallunga‚Äù pi√π progressivamente ad ogni drag per via del doppio salvataggio/ricarico.