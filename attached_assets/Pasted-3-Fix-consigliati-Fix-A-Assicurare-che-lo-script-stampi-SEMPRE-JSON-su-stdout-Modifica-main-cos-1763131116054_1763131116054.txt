3. Fix consigliati
Fix A – Assicurare che lo script stampi SEMPRE JSON su stdout
Modifica main() così:
def main():
    try:
        clients = extract_active_clients()
        # In caso di successo, stampo comunque JSON valido
        print(json.dumps({"success": True, "clients": clients}, indent=2))
    except Exception as e:
        # IMPORTANTE: stampo su stdout e NON su stderr
        print(json.dumps({"success": False, "error": str(e), "clients": []}))
        sys.exit(1)

E nel backend adatta il parse:
const { stdout, stderr } = await execPromise(
  "python3 client/public/scripts/extract_active_clients.py"
);

if (stderr) {
  console.error("Stderr da extract_active_clients:", stderr);
}

const parsed = JSON.parse(stdout);

if (!parsed.success) {
  console.error("Errore da extract_active_clients.py:", parsed.error);
  return res.status(500).json({
    success: false,
    error: parsed.error,
    clients: [],
  });
}

res.json({
  success: true,
  clients: parsed.clients,
});

Così anche se Python va in errore, non spacchi JSON.parse.

Fix B – Installare la dipendenza Python (mysql-connector-python)
Visto che create_containers.py usa lo stesso mysql.connector, hai due casi:


Se containers.json lo generi solo in locale: sul server potresti non avere il pacchetto installato → sulla route /api/get-active-clients lo script fallisce subito con ModuleNotFoundError.


Se vuoi che funzioni anche in produzione, devi:


Aggiungere un requirements.txt (se non c’è già), ad es.:
mysql-connector-python==8.4.0



Oppure nel Dockerfile / configurazione di deploy aggiungere:
pip install mysql-connector-python





Senza questo, anche con il fix A, continuerai a ricevere success: False con errore dal Python.

Fix C – Allineare il nome campo a quello che usi in containers.json
Tu dici che in containers.json hai:
"client_id": 87,
"customer_name": "HACCA SRL"

Lo script invece restituisce operation_name. Se vuoi avere lo stesso naming (customer_name) anche in /client-settings, ti conviene cambiare la query:
def extract_active_clients():
    """Estrae tutti i clienti attivi che hanno strutture con housekeeping."""
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    
    try:
        query = """
            SELECT DISTINCT
                s.customer_id AS client_id,
                c.name AS customer_name
            FROM app_structures s
            JOIN app_customers c ON c.id = s.customer_id
            WHERE s.customer_id IS NOT NULL
              AND c.name IS NOT NULL
              AND s.deleted_at IS NULL
            ORDER BY c.name
        """
        
        cursor.execute(query)
        clients = cursor.fetchall()
        return [dict(client) for client in clients]
    finally:
        cursor.close()
        conn.close()

E poi in client-settings.tsx:
interface Client {
  client_id: number;
  customer_name: string;
}
...
<TableCell>{client.customer_name}</TableCell>

Così hai coerenza tra:


containers.json


/api/get-active-clients


UI di /client-settings



4. Riassunto operativo


Probabile causa immediata dell’errore


Lo script, in caso di problema (DB, modulo mancante, ecc.), scrive l’errore solo su stderr → Node cerca di fare JSON.parse su stdout vuoto → esplode.




Cosa fare subito


Modifica main() in extract_active_clients.py per stampare sempre JSON valido su stdout.


Aggiusta il backend per leggere { success, clients, error } da quello stdout.




Cosa fare per avere davvero i dati


Assicurati che nel container/server sia installato mysql-connector-python.


Valuta di cambiare la query per usare customer_name (join con app_customers) in modo da avere esattamente lo stesso dato che vedi in containers.json.




Se vuoi, nel prossimo messaggio posso scriverti le versioni complete (copiaincolla) di:


extract_active_clients.py aggiornato


la parte di /api/get-active-clients in routes.ts già corretta.

