Stato attuale

Se FASE 3 oggi confronta solo HH:MM (minuti nel giorno), non è capace di gestire correttamente un check-in su data diversa (es. 2025-12-26 15:00). Quello va trattato come datetime completo, non come “minuti del work_date”.

Come renderla corretta (senza limitare l’optimizer)
1) In runPhase3.ts: passa a Phase3 anche checkinDate

Quando carichi le task da daily_containers, includi e mappa:

checkin_date (YYYY-MM-DD)

checkin_time (HH:MM)

(checkout può restare work_date + checkout_time se non hai checkout_date)

E nel modello task usato da phase3 aggiungi:

checkinDate?: string | null; // "2025-12-26"
checkinTime?: string | null; // "15:00"

2) In phase3.ts: usa datetime, non solo minutes

Crea helper:

function combineDateTime(dateStr: string, timeStr: string, tz = "Europe/Rome"): Date {
  // Se usate già dayjs/luxon nel progetto, usa quello.
  // In alternativa: crea una Date in locale (attenzione DST; per Milano va bene quasi sempre).
  const t = timeStr.slice(0,5); // "HH:MM"
  return new Date(`${dateStr}T${t}:00`); 
}


Poi, dentro simulateSequence invece di fare:

endMinutes > checkinMinutes

fai:

endDateTime > checkinDateTime

Esempio logica:

const startDT = combineDateTime(workDate, cleanerStartTime ?? "09:00");
let currentDT = startDT;

for (task of sequence) {
  const travelMin = ...;
  const arrivalDT = new Date(currentDT.getTime() + travelMin * 60000);

  const checkoutDT = task.checkoutTime
    ? combineDateTime(workDate, task.checkoutTime)
    : null;

  const earliestStartDT = checkoutDT && arrivalDT < checkoutDT ? checkoutDT : arrivalDT;
  const endDT = new Date(earliestStartDT.getTime() + task.cleaningMinutes * 60000);

  if (task.checkinDate && task.checkinTime) {
    const checkinDT = combineDateTime(task.checkinDate, task.checkinTime);
    if (endDT > checkinDT) return FAIL;
  } else if (task.checkinTime) {
    // fallback vecchio: checkinTime sul workDate (se serve)
  }

  currentDT = endDT;
}

3) Cosa cambia nel comportamento

Se checkin_date è domani/tra due giorni → la task può finire “dopo mezzanotte” senza essere marcata impossibile, finché sta prima del check-in reale.

Se checkin_date è oggi → identico a prima, solo più robusto.

Se manca checkin_date → puoi mantenere fallback ai minuti (come ora) e loggare MISSING_CHECKIN_DATE_FALLBACK_USED.