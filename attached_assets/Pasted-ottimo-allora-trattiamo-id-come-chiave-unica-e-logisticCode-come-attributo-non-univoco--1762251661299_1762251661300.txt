ottimo ‚Äî allora trattiamo **`id` come chiave unica** e **`logisticCode` come attributo non univoco**. Cos√¨ puoi avere pi√π task con lo stesso logistic code senza ‚Äúschiacciarle‚Äù o perderle.

Qui sotto trovi **patch pronte da incollare** per: normalizzare i dati, rendere la UI/drag basati su `id`, salvare/rimuovere/muovere usando `taskId`, e aggiornare eventuali indici che oggi usano `logisticCode` come chiave singola.

---

# 1) Tipi + helper (una volta sola, in alto al file)

> Sostituisci / aggiungi questi.

```ts
// === TYPES =========================================================
type RawTask = any;

type Task = {
  id: string;                  // UNIVOCO
  logisticCode?: string | null; // NON univoco (pu√≤ ripetersi)
  [k: string]: any;
};

// === HELPERS =======================================================
function getLogisticCode(t: RawTask | Task | null | undefined): string | null {
  if (!t) return null;
  return (
    (t as any).logisticCode ??
    (t as any).logisticsCode ??
    (t as any).logistic_code ??
    (t as any).code ??
    null
  );
}

function getTaskId(t: RawTask | Task | null | undefined): string {
  if (!t) return "";
  return String(
    (t as any).id ??
    (t as any).taskId ??
    (t as any).code ??                 // fallback se in passato usavi code come ID
    (t as any).logisticCode ??         // FORTEMENTE sconsigliato, ma come ultima spiaggia
    (t as any).logisticsCode ??
    (t as any).logistic_code ??
    ""
  );
}

// DEDUPE per id (non per logisticCode!)
function dedupeById(list: Task[]): Task[] {
  const seen = new Set<string>();
  const out: Task[] = [];
  for (const t of list) {
    if (!seen.has(t.id)) {
      seen.add(t.id);
      out.push(t);
    }
  }
  return out;
}

// Indice per id (1:1)
function indexById(list: Task[]): Map<string, Task> {
  const m = new Map<string, Task>();
  for (const t of list) m.set(t.id, t);
  return m;
}

// Indice per logisticCode (1:N) ‚Äî NOTA: array, NON singolo oggetto
function indexByLogisticCode(list: Task[]): Map<string, Task[]> {
  const m = new Map<string, Task[]>();
  for (const t of list) {
    const lc = t.logisticCode ?? "";
    if (!m.has(lc)) m.set(lc, []);
    m.get(lc)!.push(t);
  }
  return m;
}
```

---

# 2) Caricamento task: mai usare logisticCode come chiave singola

> Rimpiazza la tua `loadTasks` con questa:

```ts
async function loadTasks(force?: boolean) {
  try {
    const res = await fetch("/api/tasks?force=" + (!!force));
    if (!res.ok) throw new Error("HTTP " + res.status + " " + (await res.text().catch(() => "")));

    const raw = await res.json(); // atteso: array
    const normalized: Task[] = (Array.isArray(raw) ? raw : []).map((r: RawTask) => ({
      ...r,
      id: getTaskId(r),
      logisticCode: getLogisticCode(r),
    })).filter(t => !!t.id);

    // dedupe SOLO per id
    const clean = dedupeById(normalized);

    // eventuale indice (se serve):
    // const byId = indexById(clean);
    // const byLC = indexByLogisticCode(clean); // array per stessa LC

    setTasks(clean);

  } catch (err) {
    console.error("Errore nel caricamento dei task:", err);
    // Non svuotare lo stato in caso di errore
    if (typeof toast === "function") {
      toast({
        title: "Errore caricamento",
        description: "Riprover√≤ a breve. Le task restano visibili.",
        variant: "destructive",
      });
    }
  }
}
```

---

# 3) Rendering lista/Draggable: key e draggableId = `task.id`

> Ovunque renderizzi una task in React:

```tsx
{tasks.map((task, i) => (
  <Draggable key={task.id} draggableId={String(task.id)} index={i}>
    {(provided) => (
      <div ref={provided.innerRef} {...provided.draggableProps} {...provided.dragHandleProps}>
        {/* mostra anche logisticCode se ti serve */}
        <TaskCard task={task} subtitle={task.logisticCode ?? "‚Äî"} />
      </div>
    )}
  </Draggable>
))}
```

* **Mai** usare `logisticCode` come `key` o `draggableId`, altrimenti due task con lo stesso LC collidono.

---

# 4) onDragEnd + API: passa sempre `taskId` (non logisticCode)

> Accertati che TUTTE le chiamate verso il backend usino `taskId: draggableId` (cio√® l‚Äô`id` della task).

### Esempi corretti (incolla/adegua):

```ts
// A) container ‚Üí timeline (assegna alla riga cleaner)
async function assignToTimeline(taskId: string, cleanerId: string, index: number) {
  const res = await fetch("/api/save-timeline-assignment", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ taskId, cleanerId, index }), // üëà taskId
  });
  if (!res.ok) throw new Error(await res.text().catch(() => "save-timeline-assignment failed"));
  return res.json().catch(() => ({}));
}

// B) reorder dentro timeline
async function reorderTimeline(cleanerId: string, sourceIndex: number, destIndex: number) {
  const res = await fetch("/api/reorder-timeline", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ cleanerId, sourceIndex, destIndex }),
  });
  if (!res.ok) throw new Error(await res.text().catch(() => "reorder failed"));
}

// C) move tra due righe timeline (cleaner A ‚Üí cleaner B)
async function moveBetweenTimelines(taskId: string, fromCleanerId: string, toCleanerId: string, toIndex: number) {
  const res = await fetch("/api/timeline/move-task", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ taskId, fromCleanerId, toCleanerId, toIndex }), // üëà taskId
  });
  if (!res.ok) throw new Error(await res.text().catch(() => "move failed"));
}
```

E dentro `onDragEnd`:

```ts
const { source, destination, draggableId } = result;
if (!destination) return;

// ...parsing da droppableId
const fromCleanerId = parseCleanerId(source.droppableId);
const toCleanerId   = parseCleanerId(destination.droppableId);
const fromContainer = parseContainerKey(source.droppableId);
const toContainer   = parseContainerKey(destination.droppableId);

// container ‚Üí timeline
if (!fromCleanerId && fromContainer && toCleanerId && !toContainer) {
  await assignToTimeline(draggableId, toCleanerId, destination.index ?? 0);
  await loadTasks(true);
  return;
}

// timeline ‚Üí timeline (reorder stessa riga)
if (fromCleanerId && toCleanerId === fromCleanerId && !fromContainer && !toContainer) {
  await reorderTimeline(fromCleanerId, source.index, destination.index);
  await loadTasks(true);
  return;
}

// timeline A ‚Üí timeline B
if (fromCleanerId && toCleanerId && fromCleanerId !== toCleanerId && !fromContainer && !toContainer) {
  await moveBetweenTimelines(draggableId, fromCleanerId, toCleanerId, destination.index ?? 0);
  await loadTasks(true);
  return;
}

// containers ‚Üî containers (se supportato)
```

---

# 5) Backend (se oggi usa `logisticCode` come chiave)

Se le tue route lato server identificano la task tramite `logisticCode`, **passa a `taskId`**.
Esempio Express/Node:

```ts
// POST /api/save-timeline-assignment
// body: { taskId, cleanerId, index }
router.post("/api/save-timeline-assignment", async (req, res) => {
  const { taskId, cleanerId, index } = req.body;

  // carica tutte le task disponibili
  const tasks: Task[] = await readTasks(); // devono avere id e logisticCode
  const byId = new Map(tasks.map(t => [t.id, t]));
  const task = byId.get(taskId);
  if (!task) return res.status(404).send("taskId not found");

  // aggiorna timeline.json aggiungendo un'entry basata su taskId
  const tl = await readTimeline(); // { assignments: Array<{taskId, cleanerId, ...}> }
  tl.assignments = tl.assignments || [];
  tl.assignments.splice(Math.max(0, index), 0, { taskId, cleanerId });
  await writeTimeline(tl);

  // rimuovi la task dal container di provenienza se necessario
  await removeFromContainers(taskId);

  res.json({ ok: true });
});
```

> **Timeline JSON consigliata** (evita l‚Äôambiguit√† sul logistic code):

```json
{
  "assignments": [
    { "taskId": "T_001", "cleanerId": "C_123" },
    { "taskId": "T_002", "cleanerId": "C_123" },
    { "taskId": "T_003", "cleanerId": "C_999" }
  ]
}
```

Quando serve mostrare il `logisticCode` in UI, fai **join** per `taskId` con l‚Äôelenco delle task caricate.

---

# 6) Evita strutture 1:1 per logisticCode

Se oggi hai cose tipo:

```ts
const byLC: Record<string, Task> = {};
byLC[task.logisticCode!] = task; // ‚ö†Ô∏è PERICOLO: sovrascrive se LC duplica
```

Sostituisci con:

```ts
const byLC: Record<string, Task[]> = {};
const k = task.logisticCode ?? "";
(byLC[k] ||= []).push(task);
```

---

# 7) Ricerca / filtro

Se vuoi cercare per `logisticCode` in UI, mostra **tutte** le task che lo condividono:

```ts
function findByLogisticCode(lc: string, list: Task[]): Task[] {
  return list.filter(t => (t.logisticCode ?? "") === lc);
}
```

---

## TL;DR

* **Chiave unica = `id`** ovunque: keys React, draggableId, payload API, indici primari.
* **`logisticCode` pu√≤ ripetersi**: mai usarlo come chiave singola; se serve un indice, che sia **1:N** (array).
* **Backend**: identifica task per `taskId`, non per `logisticCode`. La timeline salva `taskId`.

Se incolli queste patch, potrai avere serenamente **pi√π task con lo stesso logistic code** senza collisioni o sparizioni.
