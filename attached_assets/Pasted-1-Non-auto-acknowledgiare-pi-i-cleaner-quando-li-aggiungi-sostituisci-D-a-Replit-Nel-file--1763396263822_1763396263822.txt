1ï¸âƒ£ Non auto-acknowledgiare piÃ¹ i cleaner quando li aggiungi/sostituisci

ğŸ‘‰ DÃ¬ a Replit:

Nel file dove câ€™Ã¨ lo stato:

const [acknowledgedIncompatibleCleaners, setAcknowledgedIncompatibleCleaners] =
  useState<Set<number>>(new Set());


cerca dentro la addCleanerMutation.onSuccess (o funzione simile) un blocco del tipo:

setAcknowledgedIncompatibleCleaners(prev => {
  const newSet = new Set(prev);
  newSet.add(cleanerId);
  if (cleanerToReplace) {
    newSet.add(cleanerToReplace);
  }
  return newSet;
});


e rimuovilo.

Se vogliamo essere piÃ¹ puliti, sostituiscilo con questo (opzionale ma consigliato):

setAcknowledgedIncompatibleCleaners(prev => {
  const newSet = new Set(prev);
  if (cleanerToReplace) {
    newSet.delete(cleanerToReplace);
  }
  newSet.delete(cleanerId); // il nuovo cleaner NON Ã¨ acknowledged di default
  return newSet;
});


Obiettivo: quando rimuovo un cleaner e ne metto uno nuovo, lâ€™incompatibilitÃ  deve tornare a vedersi, non restare â€œacknowledgedâ€ in automatico.

2ï¸âƒ£ Aggiungere la funzione che invalida lâ€™acknowledge

ğŸ‘‰ DÃ¬ a Replit:

Nel componente dove Ã¨ definito acknowledgedIncompatibleCleaners e la funzione preserveAcknowledgedState (che probabilmente esponi su window), aggiungi una funzione gemella per invalidare:

const preserveAcknowledgedState = (cleanerId: number) => {
  setAcknowledgedIncompatibleCleaners(prev => {
    const newSet = new Set(prev);
    newSet.add(cleanerId);
    return newSet;
  });
};

const invalidateAcknowledgedState = (cleanerId: number) => {
  setAcknowledgedIncompatibleCleaners(prev => {
    const newSet = new Set(prev);
    newSet.delete(cleanerId);
    return newSet;
  });
};


E nel relativo useEffect dove attacchi la funzione a window, aggiungi anche questa:

useEffect(() => {
  (window as any).preserveAcknowledgedIncompatibleCleaners = preserveAcknowledgedState;
  (window as any).invalidateAcknowledgedIncompatibleCleaners = invalidateAcknowledgedState;

  return () => {
    delete (window as any).preserveAcknowledgedIncompatibleCleaners;
    delete (window as any).invalidateAcknowledgedIncompatibleCleaners;
  };
}, []);


preserve resta per il caso â€œHo capitoâ€ o salvataggio sullo stesso cleaner.
invalidate servirÃ  quando spostiamo task tra cleaners.

3ï¸âƒ£ Usare invalidate quando fai swap/drag tra cleaners

ğŸ‘‰ DÃ¬ a Replit:

Nel file dove gestisci il drag & drop tra cleaners (lo spostamento di una task da un cleaner ad un altro / swap), cerca qualcosa del tipo:

if ((window as any).preserveAcknowledgedIncompatibleCleaners) {
  (window as any).preserveAcknowledgedIncompatibleCleaners(fromCleanerId);
  (window as any).preserveAcknowledgedIncompatibleCleaners(toCleanerId);
}


e sostituiscilo con:

if ((window as any).invalidateAcknowledgedIncompatibleCleaners) {
  (window as any).invalidateAcknowledgedIncompatibleCleaners(fromCleanerId);
  (window as any).invalidateAcknowledgedIncompatibleCleaners(toCleanerId);
}


CosÃ¬, quando:

fai uno swap tra due cleaners,

trascini una task verso un cleaner non compatibile,

lâ€™acknowledge viene cancellato per quei cleaners e lâ€™effetto isIncompatible torna a farsi vedere se câ€™Ã¨ di nuovo incompatibilitÃ .

4ï¸âƒ£ Cosa NON cambiare

Il click su â€œHo capitoâ€ deve continuare a fare:

setAcknowledgedIncompatibleCleaners(prev => new Set(prev).add(cleanerId));


La chiamata a preserveAcknowledgedIncompatibleCleaners dopo aver salvato il modal della stessa task sullo stesso cleaner puÃ² restare, se la usi.