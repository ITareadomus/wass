Perfetto, allora facciamo pulizia totale di MySQL e lasciamo solo PostgreSQL.

Ti metto un‚Äôunica patch grande che:

Rimuove completamente MySQL (file, import, connessioni, endpoint).

Aggiorna workspace-files.ts per togliere ogni riferimento a MySQL (questa include anche la patch che ti avevo descritto prima).

Aggiorna gli endpoint in routes.ts per usare solo PostgreSQL (anche per /api/check-saved-assignments).

Rimuove mysql2 da package.json.

Puoi incollare tutto in Replit ‚Üí Tools ‚Üí AI ‚Üí Apply Patch (oppure modificarli a mano partendo da qui).

*** Begin Patch
*** Delete File: TaskFlowMaster/server/services/daily-assignment-revisions-service.ts
*** End Patch

*** Begin Patch
*** Delete File: TaskFlowMaster/shared/mysql-db.ts
*** End Patch

1Ô∏è‚É£ server/services/workspace-files.ts ‚Äì rimozione MySQL legacy
*** Begin Patch
*** Update File: TaskFlowMaster/server/services/workspace-files.ts
@@
-import * as fs from 'fs/promises';
-import path from 'path';
-import { dailyAssignmentRevisionsService } from './daily-assignment-revisions-service';
-import { formatInTimeZone } from 'date-fns-tz';
+import * as fs from 'fs/promises';
+import path from 'path';
+import { formatInTimeZone } from 'date-fns-tz';
@@
-    // Save to history for audit/rollback
-    if (!skipRevision) {
-      await pgDailyAssignmentsService.saveToHistory(
-        workDate, 
-        normalizedData, 
-        createdBy, 
-        modificationType,
-        editedFields,
-        oldValues,
-        newValues
-      );
-      console.log(`‚úÖ Timeline history saved for ${workDate} by ${createdBy}`);
-    }
-
-    // LEGACY: Also save to MySQL for backward compatibility (will be removed)
-    if (!isPastDate && !skipRevision) {
-      try {
-        const selected = await loadSelectedCleanersFromPg(workDate);
-        const cleanersArray = selected?.cleaners || [];
-        const containers = await loadContainersInternal(workDate);
-        await dailyAssignmentRevisionsService.createRevision(wor...rsArray, containers, createdBy, modificationType, editOptions);
-        console.log(`‚ö†Ô∏è Timeline revision created in MySQL (legacy) for ${workDate}`);
-      } catch (mysqlError) {
-        console.warn(`‚ö†Ô∏è MySQL legacy save failed (non-blocking):`, mysqlError);
-      }
-    }
+    // Save to history for audit/rollback (PostgreSQL only)
+    if (!skipRevision) {
+      await pgDailyAssignmentsService.saveToHistory(
+        workDate, 
+        normalizedData, 
+        createdBy, 
+        modificationType,
+        editedFields,
+        oldValues,
+        newValues
+      );
+      console.log(`‚úÖ Timeline history saved in PostgreSQL for ${workDate} by ${createdBy}`);
+    }
@@
-export async function saveContainers(workDate: string, data...ystem', modificationType: string = 'manual'): Promise<boolean> {
+export async function saveContainers(workDate: string, data...ystem', modificationType: string = 'manual'): Promise<boolean> {
   try {
     // Save to PostgreSQL (primary and only storage)
     const { pgDailyAssignmentsService } = await import('./pg-daily-assignments-service');
     await pgDailyAssignmentsService.saveContainers(workDate, data);
     console.log(`‚úÖ Containers saved to PostgreSQL for ${workDate}`);
-
-    // LEGACY: Also save to MySQL for backward compatibility (will be removed)
-    const today = new Date();
-    today.setHours(0, 0, 0, 0);
-    const targetDate = new Date(workDate);
-    targetDate.setHours(0, 0, 0, 0);
-    const isPastDate = targetDate < today;
-
-    if (!isPastDate) {
-      try {
-        const timeline = await loadTimeline(workDate);
-        const selected = await loadSelectedCleanersFromPg(workDate);
-        const cleanersArray = selected?.cleaners || [];
-        await dailyAssignmentRevisionsService.createRevisio...eline || {}, cleanersArray, data, createdBy, modificationType);
-        console.log(`‚ö†Ô∏è Containers revision created in MySQL (legacy) for ${workDate}`);
-      } catch (mysqlError) {
-        console.warn(`‚ö†Ô∏è MySQL legacy save failed (non-blocking):`, mysqlError);
-      }
-    }
-
     return true;
   } catch (err) {
@@
-/**
- * Save selected_cleaners for a specific work date
- * PRIMARY: PostgreSQL (IDs to daily_selected_cleaners, full data to cleaners table)
- * LEGACY: MySQL (will be removed)
- */
+/**
+ * Save selected_cleaners for a specific work date
+ * PRIMARY: PostgreSQL (IDs to daily_selected_cleaners, full data to cleaners table)
+ */
 export async function saveSelectedCleaners(workDate: string...ystem', modificationType: string = 'manual'): Promise<boolean> {
@@
-    if (skipRevision) {
-      console.log(`‚è≠Ô∏è Saltata revisione MySQL per ${workDate} (skipRevision=true)`);
-      return true;
-    }
-
-    // LEGACY: Also save to MySQL (will be removed)
-    try {
-      const timeline = await loadTimeline(workDate);
-      const containers = await loadContainersInternal(workDate);
-      const cleanersForMySQL = data.cleaners || [];
-      await dailyAssignmentRevisionsService.createRevision(...{}, cleanersForMySQL, containers, createdBy, modificationType);
-      console.log(`‚ö†Ô∏è Selected cleaners revision created in MySQL (legacy) for ${workDate}`);
-    } catch (mysqlError) {
-      console.warn(`‚ö†Ô∏è MySQL legacy save failed (non-blocking):`, mysqlError);
-    }
-
-    return true;
+    if (skipRevision) {
+      console.log(`‚è≠Ô∏è Saltata creazione revisione per ${workDate} (skipRevision=true)`);
+      return true;
+    }
+
+    // Nessuna scrittura legacy: PostgreSQL √® l‚Äôunica fonte di verit√†
+    return true;
@@
-    // LEGACY: Also save to MySQL
-    try {
-      const selected = await loadSelectedCleanersFromPg(workDate);
-      const containers = await loadContainersInternal(workDate);
-      if (selected?.cleaners && selected.cleaners.length > 0) {
-        await dailyAssignmentRevisionsService.createRevisio...e, selected.cleaners, containers, createdBy, modificationType);
-        console.log(`‚ö†Ô∏è Timeline reset revision created in MySQL (legacy) for ${workDate}`);
-      }
-    } catch (mysqlError) {
-      console.warn(`‚ö†Ô∏è MySQL legacy reset failed (non-blocking):`, mysqlError);
-    }
-
-    return true;
+    // Nessuna revisione legacy MySQL: reset gestito solo su PostgreSQL
+    return true;
*** End Patch


Nota: dove vedi data...ystem / createRevisio... ecc, sono esattamente le stringhe gi√† presenti nel file (sono rotte nel repo). Il patch sopra le elimina/aggira tutte le parti che chiamano MySQL.

2Ô∏è‚É£ server/index.ts ‚Äì niente pi√π init MySQL
*** Begin Patch
*** Update File: TaskFlowMaster/server/index.ts
@@
-import express, { type Request, Response, NextFunction } from "express";
-import { registerRoutes } from "./routes";
-import { setupVite, serveStatic, log } from "./vite";
-import { fileURLToPath } from "url";
-import path from "path";
-import { initMySQLDatabase, testMySQLConnection } from "../shared/mysql-db";
+import express, { type Request, Response, NextFunction } from "express";
+import { registerRoutes } from "./routes";
+import { setupVite, serveStatic, log } from "./vite";
+import { fileURLToPath } from "url";
+import path from "path";
@@
-(async () => {
-  // Initialize MySQL connection and verify table exists
-  log("üîå Connecting to MySQL database...");
-  const mysqlOk = await testMySQLConnection();
-  if (mysqlOk) {
-    await initMySQLDatabase();
-  } else {
-    console.error("‚ö†Ô∏è MySQL connection failed - storage will use filesystem fallback");
-  }
-
-  const server = await registerRoutes(app);
+(async () => {
+  const server = await registerRoutes(app);
*** End Patch

3Ô∏è‚É£ server/routes.ts ‚Äì tutto su PostgreSQL, niente pi√π MySQL
3.1 Commenti iniziali (solo testo)
*** Begin Patch
*** Update File: TaskFlowMaster/server/routes.ts
@@
-      console.log(`üìñ GET /api/timeline - Caricamento timeline per ${workDate}`);
-
-      // Carica la timeline da PostgreSQL (con fallback su MySQL e filesystem)
+      console.log(`üìñ GET /api/timeline - Caricamento timeline per ${workDate}`);
+
+      // Carica la timeline da PostgreSQL (con eventuale fallback su filesystem)
@@
-  // Endpoint per leggere i cleaners selezionati da PostgreSQL/MySQL
+  // Endpoint per leggere i cleaners selezionati da PostgreSQL
*** End Patch

3.2 /api/check-saved-assignments ‚Äì ora legge le revisioni da PostgreSQL
*** Begin Patch
*** Update File: TaskFlowMaster/server/routes.ts
@@
-  // Endpoint per verificare SE esistono assegnazioni salvate in MySQL (senza caricarle)
+  // Endpoint per verificare SE esistono assegnazioni salvate in database (senza caricarle)
   app.post("/api/check-saved-assignments", async (req, res) => {
     try {
-      const { dailyAssignmentRevisionsService } = await import("./services/daily-assignment-revisions-service");
-
       const workDate = req.body?.date || format(new Date(), "yyyy-MM-dd");
-
-      const revision = await dailyAssignmentRevisionsService.getLatestRevision(workDate);
-
-      if (revision) {
-        const d = new Date(workDate);
-        return res.json({
-          success: true,
-          found: true,
-          revision: revision.revision,
-          formattedDateTime: format(d, "dd/MM/yyyy", { locale: it })
-        });
-      }
-
-      // Nessuna revisione trovata
-      return res.json({ success: true, found: false });
+      const { pgDailyAssignmentsService } = await import("./services/pg-daily-assignments-service");
+
+      // Usa la tabella daily_assignments_revisions (PostgreSQL) come sorgente di verit√†
+      const revisions = await pgDailyAssignmentsService.getHistoryRevisions(workDate);
+
+      if (revisions && revisions.length > 0) {
+        const latest = revisions[0];
+        const createdAt = latest.created_at ? new Date(latest.created_at) : new Date(workDate);
+
+        return res.json({
+          success: true,
+          found: true,
+          revision: latest.revision,
+          formattedDateTime: format(createdAt, "dd/MM/yyyy HH:mm", { locale: it })
+        });
+      }
+
+      // Nessuna revisione trovata
+      return res.json({ success: true, found: false });
*** End Patch

3.3 Endpoint deprecato + load-saved-assignments ‚Äì solo testo
*** Begin Patch
*** Update File: TaskFlowMaster/server/routes.ts
@@
-  // [DEPRECATED] Endpoint per confermare le assegnazioni - ora il salvataggio √® automatico su MySQL
+  // [DEPRECATED] Endpoint per confermare le assegnazioni - ora il salvataggio √® automatico su PostgreSQL
   app.post("/api/confirm-assignments", async (req, res) => {
-    // Questo endpoint non √® pi√π necessario - il salvataggio avviene automaticamente
-    // via workspace-files.ts che crea revisioni in MySQL ad ogni modifica
+    // Questo endpoint non √® pi√π necessario - il salvataggio avviene automaticamente
+    // via workspace-files.ts che salva in PostgreSQL ad ogni modifica
@@
-  // Endpoint per caricare assegnazioni salvate da MySQL
+  // Endpoint per caricare assegnazioni salvate dal database (PostgreSQL)
   app.post("/api/load-saved-assignments", async (req, res) => {
@@
-      console.log(`üì• Caricamento assegnazioni da MySQL per ${workDate}...`);
-
-      // Carica timeline, selected_cleaners E CONTAINERS da MySQL via workspace-files
+      console.log(`üì• Caricamento assegnazioni dal database per ${workDate}...`);
+
+      // Carica timeline, selected_cleaners E CONTAINERS da PostgreSQL via workspace-files
*** End Patch

3.4 Fallback containers ‚Äì rimozione riferimenti a MySQL (solo log)
*** Begin Patch
*** Update File: TaskFlowMaster/server/routes.ts
@@
-      } catch (err) {
-        console.error('‚ùå Errore nella rigenerazione containers:', err);
-        // Fallback: se c'√® un errore, usa i containers salvati in MySQL se disponibili
-        if (!containersData) {
-          console.warn('‚ö†Ô∏è Impossibile rigenerare containers e nessun dato in MySQL');
-        }
-      }
+      } catch (err) {
+        console.error('‚ùå Errore nella rigenerazione containers:', err);
+        if (!containersData) {
+          console.warn('‚ö†Ô∏è Impossibile rigenerare containers e nessun dato containers salvato disponibile');
+        }
+      }
*** End Patch

3.5 Messaggi ‚Äúcaricate da MySQL‚Äù
*** Begin Patch
*** Update File: TaskFlowMaster/server/routes.ts
@@
-        message: `Assegnazioni caricate da MySQL per ${workDate}`
+        message: `Assegnazioni caricate dal database per ${workDate}`
*** End Patch

3.6 selected_cleaners salva via workspace helper ‚Äì commento
*** Begin Patch
*** Update File: TaskFlowMaster/server/routes.ts
@@
-      // Salva selected_cleaners usando workspace helper (dual-write: filesystem + MySQL)
+      // Salva selected_cleaners usando workspace helper (database PostgreSQL + filesystem come cache)
*** End Patch

3.7 start_time update ‚Äì commento MySQL revisione
*** Begin Patch
*** Update File: TaskFlowMaster/server/routes.ts
@@
-            // Salva timeline su PostgreSQL (skipRevision=true)
-            // La revisione MySQL viene creata da /api/save-selected-cleaners al termine
+            // Salva timeline su PostgreSQL (skipRevision=true)
*** End Patch

3.8 Task edit ‚Äì rimozione tracking ‚Äúper MySQL‚Äù e propagazione MySQL
*** Begin Patch
*** Update File: TaskFlowMaster/server/routes.ts
@@
-      // Prepara opzioni di tracking per MySQL history
+      // Prepara opzioni di tracking per la history (PostgreSQL)
       const editOptions = editedFields.length > 0 ? {
         editedField: editedFields.join(', '),
         oldValue: oldValues.join(', '),
         newValue: newValues.join(' ')
       } : undefined;
@@
-      // Salva containers (filesystem + MySQL)
+      // Salva containers (PostgreSQL + cache filesystem)
       await workspaceFiles.saveContainers(workDate, containersData);
       
-      // Salva timeline con tracking delle modifiche (skipRevision=false per creare revision in MySQL)
+      // Salva timeline con tracking delle modifiche (skipRevision=false per creare una nuova revisione in PostgreSQL)
       await workspaceFiles.saveTimeline(workDate, timelineData, false, currentUsername, 'task_edit', editOptions);
-
-      // CRITICAL: Propaga le modifiche al database MySQL (app_housekeeping E wass_housekeeping)
-      if (taskId) {
-        try {
-          const mysql = await import('mysql2/promise');
-          const connection = await mysql.createConnection({
-            host: "139.59.132.41",
-            user: "taskflow",
-            password: process.env.MYSQL_SYNC_PASSWORD,
-            database: "app_housekeeping",
-            port: 3306
-          });
-
-          const updates: string[] = [];
-          const values: any[] = [];
-
-          if (typeof premium === "boolean") {
-            updates.push("premium = ?");
-            values.push(premium ? 1 : 0);
-          }
-
-          if (typeof cleaningTime === "number") {
-            updates.push("cleaning_time = ?");
-            values.push(cleaningTime);
-          }
-
-          if (typeof pax === "number") {
-            updates.push("pax = ?");
-            values.push(pax);
-          }
-
-          if (typeof city === "string") {
-            updates.push("city = ?");
-            values.push(city);
-          }
-
-          if (updates.length > 0) {
-            values.push(taskId); // WHERE id = ?
-            
-            // Aggiorna SOLO wass_housekeeping
-            const query = `UPDATE wass_housekeeping SET ${updates.join(', ')} WHERE id = ?`;
-            await connection.execute(query, values);
-            console.log(`‚úÖ Task ${logisticCode} aggiornata su wass_housekeeping`);
-
-            await connection.end();
-          }
-        } catch (dbError: any) {
-          console.error('‚ö†Ô∏è Errore aggiornamento database MySQL:', dbError.message);
-          // Non bloccare la risposta, i file JSON sono comunque salvati
-        }
-      }
*** End Patch

3.9 Endpoint cancellazione revisioni MySQL ‚Äì rimosso
*** Begin Patch
*** Update File: TaskFlowMaster/server/routes.ts
@@
-  // Endpoint per eliminare revisioni MySQL per una data specifica (pulizia dati errati)
-  app.delete("/api/mysql-revisions/:workDate", async (req, res) => {
-    try {
-      const { workDate } = req.params;
-      const { dailyAssignmentRevisionsService } = await import("./services/daily-assignment-revisions-service");
-
-      if (!workDate || !/^\d{4}-\d{2}-\d{2}$/.test(workDate)) {
-        return res.status(400).json({
-          success: false,
-          error: "Data non valida. Formato richiesto: YYYY-MM-DD"
-        });
-      }
-
-      const deletedCount = await dailyAssignmentRevisionsService.deleteAllRevisionsForDate(workDate);
-
-      res.json({
-        success: true,
-        deletedCount,
-        message: `Eliminate ${deletedCount} revisioni MySQL per ${workDate}`
-      });
-    } catch (error: any) {
-      console.error("Errore nella cancellazione revisioni MySQL:", error);
-      res.status(500).json({ success: false, error: error.message });
-    }
-  });
-
*** End Patch

4Ô∏è‚É£ package.json ‚Äì rimozione mysql2
*** Begin Patch
*** Update File: TaskFlowMaster/package.json
@@
-    "@hookform/resolvers": "^3.10.0",
-    "@jridgewell/trace-mapping": "^0.3.25",
-    "@neondatabase/serverless": "^0.10.4",
-    "mysql2": "^3.11.3",
+    "@hookform/resolvers": "^3.10.0",
+    "@jridgewell/trace-mapping": "^0.3.25",
+    "@neondatabase/serverless": "^0.10.4",
*** End Patch

Dopo il patch

Dopo aver applicato tutte queste modifiche:

Il progetto non importa pi√π MySQL da nessuna parte.

Non esistono pi√π:

shared/mysql-db.ts

daily-assignment-revisions-service.ts

endpoint /api/mysql-revisions/*

la propagazione verso wass_housekeeping via mysql2.

Tutti i salvataggi/letture per timeline, containers, selected_cleaners e revisioni passano solo da PostgreSQL (pg-daily-assignments-service + workspace-files.ts).