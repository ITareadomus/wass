Ok, allora il problema â€œplaceholder + buco vuotoâ€ non dipende dal placeholder in sÃ©: succede quasi sempre quando la Draggable che stai trascinando continua a occupare spazio nel layout (anche solo come â€œghostâ€ con opacity: 0 / wrapper che non riceve lo style di RBDND), mentre in piÃ¹ tu inserisci il provided.placeholder.

Quindi: teniamo la tua struttura â€œbellaâ€ (placeholder in mezzo che segue lâ€™indice), ma sistemiamo due cose:

Il placeholder deve essere renderizzato UNA sola volta (o tra due task oppure in fondo, non entrambi).

Lo style di provided.draggableProps.style deve stare sullâ€™elemento che occupa spazio (quello col ref), senza essere sovrascritto, altrimenti lâ€™item trascinato resta â€œin flowâ€ â‡’ buco doppio.

âœ… Modifica 1 â€” Placeholder â€œin mezzoâ€ che segue il drop (senza buco doppio)

In timeline-view.tsx, dentro il Droppable del cleaner:

A) Calcola un solo placeholderIndex

Usa lastValidDragIndex + draggingOverCleanerId (come giÃ  hai in stato):

const placeholderIndex =
  draggingOverCleanerId === cleaner.id && lastValidDragIndex !== null
    ? lastValidDragIndex
    : null;

B) Dentro cleanerTasks.map(...) inserisci il placeholder PRIMA della TaskCard
{cleanerTasks.map((task, idx) => (
  <React.Fragment key={task.id}>
    {placeholderIndex === idx && provided.placeholder}

    {/* Draggable/TaskCard qui */}
  </React.Fragment>
))}

C) Se lâ€™indice Ã¨ â€œin codaâ€, rendi il placeholder dopo la lista
{placeholderIndex !== null && placeholderIndex >= cleanerTasks.length && provided.placeholder}

D) Rimuovi ogni altro provided.placeholder â€œdi defaultâ€ in fondo

Se in fondo avevi un {provided.placeholder} fisso, toglilo: altrimenti lo vedi â€œimpilato per ultimoâ€.

Questa struttura ti dÃ  esattamente: placeholder tra due task, senza far sparire task, e senza duplicarlo.

âœ… Modifica 2 â€” Elimina il â€œbuco vuotoâ€ (la vera causa)

Ora la parte critica: dentro ogni Draggable, lâ€™elemento che riceve ref + draggableProps deve avere anche style={provided.draggableProps.style} e non deve essere sovrascritto da altri wrapper.

PRIMA (tipico caso che crea buco doppio)

metti lo style su un elemento diverso

oppure lo sostituisci con un tuo style={{...}}

oppure TaskCard ha wrapper che impone layout e lo stile RBDND non arriva dove deve

DOPO (corretto)

Nel render del Draggable:

<Draggable draggableId={String(task.id)} index={idx}>
  {(provided, snapshot) => (
    <div
      ref={provided.innerRef}
      {...provided.draggableProps}
      {...provided.dragHandleProps}
      style={provided.draggableProps.style}   // <-- FONDAMENTALE
    >
      <TaskCard task={task} /* ... */ />
    </div>
  )}
</Draggable>


Se devi aggiungere tuo stile/classi, non sostituire lo style, ma fai merge senza toccare position/transform/top/left:

const dragStyle = provided.draggableProps.style;

<div
  ...
  style={{
    ...dragStyle,
    // ok aggiungere SOLO cose innocue:
    // margin, width, flexShrink ecc. (ma NON position/transform)
  }}
>


ğŸš« Importantissimo: non usare opacity: 0, visibility: hidden, display: none sul draggable â€œoriginaleâ€ mentre snapshot.isDragging â†’ quello crea esattamente il secondo buco.

Checklist veloce (se vuoi verificare in 30 secondi)

Nel Droppable per colonna: provided.placeholder compare solo nei 2 punti (tra items o in coda), mai altrove.

Nel Draggable: style={provided.draggableProps.style} Ã¨ sullâ€™elemento col ref.

Nessuna classe tipo opacity-0 / invisible durante il drag.