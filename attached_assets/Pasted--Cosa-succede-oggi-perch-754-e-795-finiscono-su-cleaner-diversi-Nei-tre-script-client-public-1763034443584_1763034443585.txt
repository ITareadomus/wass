üîç Cosa succede oggi (perch√© 754 e 795 finiscono su cleaner diversi)

Nei tre script:

client/public/scripts/assign_eo.py

client/public/scripts/assign_hp.py

client/public/scripts/assign_lp.py

hai gi√†:

Clustering preventivo cross-container
In plan_day(...):

carichi timeline.json

costruisci assigned_tasks_by_location

raggruppi le task del container corrente in:

gruppi per stesso edificio

gruppi cross-container se vicine (same_building / same_zone) a task gi√† presenti in timeline.json.

üëâ Questo fa s√¨ che task come 754 e 795 finiscano nello stesso gruppo e vengano processate vicine tra loro.

Seed dei cleaner da timeline (solo HP/LP)
In assign_hp.py (seed_cleaners_from_eo) e in assign_lp.py (seed_cleaners_from_timeline) leggi timeline.json per:

impostare available_from

salvare ultima posizione EO / HP.

Cross-container ‚ÄúPRIORIT√Ä ASSOLUTA‚Äù solo per stesso edificio
In HP e LP, prima di calcolare i candidates, fai:

same_building_cleaner = None
for cleaner in cleaners:
    # 1) controlla route (task HP/LP gi√† assegnate)
    # 2) controlla tutte le task di quel cleaner in timeline.json
    #    -> if same_building(t.address, task.address) -> same_building_cleaner = cleaner


Se lo trovi, provi ad assegnare subito a lui.

üéØ MA: la parte cross-container basata su same_zone (vicinanza geografica) viene usata:

solo nel clustering preventivo (raggruppare le task tra loro),

non nella scelta del cleaner a cui assegnare la nuova task.

Quindi, se:

Task 754 (container A) √® stata assegnata a Cleaner X

Task 795 (container B) √® molto vicina (stessa zona) a 754
üëâ viene messa nello stesso gruppo di elaborazione,
ma quando scegli il cleaner per 795:

guardi solo route (HP/LP correnti) + same_building in timeline

non controlli ‚Äústessa zona in timeline per questo cleaner‚Äù.

Risultato: 795 viene data al cleaner che ha il viaggio migliore nel container corrente, NON necessariamente a quello che ha gi√† 754 in quella zona ‚Üí per questo te le ritrovi spezzate.

‚úÖ Fix concettuale: dare priorit√† anche alla ‚Äústessa ZONA‚Äù cross-container

L‚Äôidea:

HP e LP

Estendere la ‚ÄúPRIORIT√Ä ASSOLUTA‚Äù (adesso solo stesso edificio) per considerare anche:

tasks in stessa zona (same_zone) presenti in timeline.json.

Se un cleaner ha una task in timeline nella stessa zona della task corrente, lo trattiamo come candidato preferito, subito dopo eventuali match di edificio.

(Opzionale) EO

EO legge gi√† timeline.json per clustering preventivo; se vuoi replay/riassegnazioni multiple nello stesso giorno, puoi applicare la stessa logica anche l√¨.

Ma il problema che descrivi (754/795 su cleaner diversi) molto probabilmente nasce tra EO ‚Üí HP o HP ‚Üí LP, quindi sistemare HP + LP √® la parte cruciale.

üîß Modifiche concrete ‚Äì assign_hp.py
1. Hai gi√† ZONE_RADIUS_KM e same_zone

All‚Äôinizio del file:

ZONE_RADIUS_KM = 0.25  # ~250m, micro-zona


e pi√π sotto:

def same_zone(a_lat: float, a_lng: float, b_lat: float, b_lng: float,
              a_addr: Optional[str] = None, b_addr: Optional[str] = None) -> bool:
    """
    Zona condivisa se:
    - stesso edificio
    - oppure stessa via
    - oppure distanza <= ZONE_RADIUS_KM
    """
    if a_addr and b_addr and same_building(a_addr, b_addr):
        return True
    if a_addr and b_addr and same_street(a_addr, b_addr):
        return True

    try:
        km = haversine_km(a_lat, a_lng, b_lat, b_lng)
    except Exception:
        return False

    return km <= ZONE_RADIUS_KM


Questa funzione √® perfetta per quello che ci serve üëå

2. Estendere la ‚ÄúPRIORIT√Ä ASSOLUTA‚Äù in plan_day (HP)

Cerca il blocco (circa riga ~700):

        same_building_cleaner = None
        for cleaner in cleaners:
            # Controlla task HP gi√† in route
            if any(same_building(existing_task.address, task.address) for existing_task in cleaner.route):
                same_building_cleaner = cleaner
                break
            # CROSS-CONTAINER: Controlla TUTTE le task gi√† assegnate al cleaner nella timeline
            # Carica timeline e verifica task vicine
            timeline_path = OUTPUT_ASSIGN.parent / "timeline.json"
            if timeline_path.exists():
                try:
                    timeline_data = json.loads(timeline_path.read_text(encoding="utf-8"))
                    for cleaner_entry in timeline_data.get("cleaners_assignments", []):
                        if cleaner_entry["cleaner"]["id"] == cleaner.id:
                            # Controlla tutte le task del cleaner
                            for t in cleaner_entry.get("tasks", []):
                                if same_building(t.get("address"), task.address):
                                    same_building_cleaner = cleaner
                                    priority = t.get("priority", "unknown")
                                    print(f"   üîÑ CROSS-CONTAINER...sk.task_id} vicina a task {priority.upper()} di {cleaner.name}")
                                    break
                            if same_building_cleaner:
                                break
                except:
                    ...


Sostituiscilo con una versione che:

legge timeline.json una sola volta

introduce anche same_zone_cleaner:

        same_building_cleaner = None
        same_zone_cleaner = None

        # Leggi timeline una sola volta
        timeline_data = None
        timeline_path = OUTPUT_ASSIGN.parent / "timeline.json"
        if timeline_path.exists():
            try:
                timeline_data = json.loads(timeline_path.read_text(encoding="utf-8"))
            except Exception as e:
                print(f"   ‚ö†Ô∏è Errore caricamento timeline per clustering cross-container: {e}")
                timeline_data = None

        for cleaner in cleaners:
            # 1) Controlla task HP gi√† in route (stesso edificio)
            if any(same_building(existing_task.address, task.address) for existing_task in cleaner.route):
                same_building_cleaner = cleaner
                break

            # 2) CROSS-CONTAINER: controlla tutte le task di questo cleaner in timeline
            if timeline_data:
                for cleaner_entry in timeline_data.get("cleaners_assignments", []):
                    if cleaner_entry["cleaner"]["id"] != cleaner.id:
                        continue

                    for t in cleaner_entry.get("tasks", []):
                        t_addr = t.get("address")
                        t_lat = t.get("lat")
                        t_lng = t.get("lng")

                        # 2a) stesso edificio -> priorit√† massima
                        if same_building(t_addr, task.address):
                            same_building_cleaner = cleaner
                            priority = t.get("priority", "unknown")
                            print(f"   üîÑ CROSS-CONTAINER EDIFICIO: task {task.task_id} vicina a task {priority.upper()} di {cleaner.name}")
                            break

                        # 2b) stessa ZONA -> memorizza come candidato di zona
                        if t_lat is not None and t_lng is not None:
                            if same_zone(float(t_lat), float(t_lng),
                                         task.lat, task.lng,
                                         t_addr, task.address):
                                if same_zone_cleaner is None:
                                    same_zone_cleaner = cleaner
                                    priority = t.get("priority", "unknown")
                                    print(f"   üîÑ CROSS-CONTAINER ZONA: task {task.task_id} vicina (zona) a task {priority.upper()} di {cleaner.name}")
                    if same_building_cleaner:
                        break

            if same_building_cleaner:
                break

        # Usa prima stesso edificio, altrimenti stessa zona
        target_cleaner = same_building_cleaner or same_zone_cleaner
        if target_cleaner:
            result = find_best_position(target_cleaner, task)
            if result is not None:
                pos, travel = result
                target_cleaner.route.insert(pos, task)
                assigned_logistic_codes.add(task.logistic_code)
                print(f"   üß© Task {task.task_id} assegnata a {target_cleaner.name} (cross-container: {task.address})")
                continue
            else:
                print(f"   ‚ö†Ô∏è  Task {task.task_id} vicina a {target_cleaner.name} ma limite raggiunto")


Cos√¨:

se 754 √® gi√† in timeline, assegnata a Cleaner X

795 entra in HP:

il loop trova, in timeline, una task di X in same_zone
‚Üí same_zone_cleaner = X
‚Üí target_cleaner = X

provi a inserirla nella route di X con find_best_position (rispettando vincoli)

solo se non fattibile passi alla logica normale.

üîß Modifiche analoghe ‚Äì assign_lp.py

Stesso schema in plan_day di LP:

Nel blocco dove ora fai:

same_building_cleaner = None
for cleaner in cleaners:
    # route
    # CROSS-CONTAINER: same_building su timeline...


Introduci:

same_building_cleaner = None
same_zone_cleaner = None
# timeline_data = ...
# per ciascun cleaner:
#   - same_building su route
#   - same_building su timeline
#   - same_zone su timeline (usando same_zone(...))
# target_cleaner = same_building_cleaner or same_zone_cleaner
# se target_cleaner: find_best_position + insert, poi continue


La funzione same_zone in LP √® gi√† definita e usata per altre parti del clustering, quindi puoi riusarla esattamente come in HP.

(Opzionale) Coerenza dei raggi di zona

Al momento hai:

EO: ZONE_RADIUS_KM = 0.8

HP: ZONE_RADIUS_KM = 0.25

LP: ZONE_RADIUS_KM = 0.8

Se vuoi un comportamento uniforme visivamente coerente tipo ‚Äústesso isolato / stessa zona pedonale‚Äù, io ti suggerirei:

per tutto il cross-container same_zone (EO/HP/LP): 0.2‚Äì0.3 km
(cos√¨ via Tortona / via Voghera / incroci simili diventano un cluster stabile).

Effetto atteso su 754 & 795

Dopo questi fix:

Il container che viene eseguito per primo (es. EO) assegna 754 al suo cleaner (es. Alexander).

Quando viene eseguito il container successivo dove c‚Äô√® 795:

timeline.json contiene gi√† 754 con lat/lng/address e priority.

In plan_day di HP/LP, il loop:

controlla tutte le task del cleaner X in timeline

vede che una √® in same_zone con 795

marca X come same_zone_cleaner.

target_cleaner = X
‚Üí si prova prima di tutto a mettere 795 nella route di X.
Solo se impossibile per vincoli di orario/limiti, si ripiega su altri cleaner.

Quindi nella stragrande maggioranza dei casi 754 e 795 finiranno sullo stesso cleaner, che √® proprio quello che vuoi per cluster ‚Äúintelligenti‚Äù cross-container.