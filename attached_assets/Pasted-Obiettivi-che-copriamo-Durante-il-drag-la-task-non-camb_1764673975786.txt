Obiettivi che copriamo
Durante il drag la task non cambia dimensione ‚Üí tolgo tutti gli scale legati al drag.


Zona di drop evidenziata solo dove cadr√† la task ‚Üí uso la placeholder di react-beautiful-dnd al posto di colorare tutta la riga.


Piccolo tooltip con il numero di sequenza mentre trascini ‚Üí uso onDragUpdate del DragDropContext e un piccolo overlay fisso.


Caricamento non invasivo per i movimenti delle task ‚Üí niente spinner globale per refreshAssignments("manual"), resta in background.


Hitbox pi√π precisa ‚Üí conseguenza del punto (1): niente pi√π transform/scale durante il drag.


L‚Äôultimo punto ‚Äúsposta automaticamente le altre task considerando travel time‚Äù lo tratto solo come idee alla fine, senza codice.

1. Task che non cambiano dimensione durante il drag + hitbox
File: client/src/components/drag-drop/task-card.tsx
Cerca il blocco del Draggable con il className e lo style del wrapper:
<Draggable
  draggableId={getTaskKey(task)}
  index={index}
  isDragDisabled={shouldDisableDrag} // Usa la prop per disabilitare il drag
>
  {(provided, snapshot) => {
    const cardWidth = calculateWidth(task.duration, isInTimeline);

    return (
      <TooltipProvider delayDuration={300}>
        <Tooltip>
          <TooltipTrigger asChild>
            <div
              ref={provided.innerRef}
              {...provided.draggableProps}
              {...provided.dragHandleProps}
              className={`
                ${cardColorClass}
                rounded-sm px-2 py-1 shadow-sm transition-all duration-200 border
                ${snapshot.isDragging ? "shadow-lg scale-105" : ""}
                ${isOverdue && isInTimeline ? "animate-blink" : ""}
                ${isDuplicate && !isInTimeline ? "animate-blink-yellow" : ""}
                hover:shadow-md cursor-pointer
                flex-shrink-0 relative
              `}
              style={{
                ...provided.draggableProps.style,
                width: cardWidth,
                minHeight: "40px",
                ...(isMapFiltered ? {
                  boxShadow: '0 0 0 3px #3B82F6, 0 0 20px 5px rgba(59, 130, 246, 0.5)',
                  transform: 'scale(1.05)',
                  zIndex: 10,
                } : {})
              }}

Sostituiscilo con:
<Draggable
  draggableId={getTaskKey(task)}
  index={index}
  isDragDisabled={shouldDisableDrag} // Usa la prop per disabilitare il drag
>
  {(provided, snapshot) => {
    const cardWidth = calculateWidth(task.duration, isInTimeline);

    return (
      <TooltipProvider delayDuration={300}>
        <Tooltip>
          <TooltipTrigger asChild>
            <div
              ref={provided.innerRef}
              {...provided.draggableProps}
              {...provided.dragHandleProps}
              className={`
                ${cardColorClass}
                rounded-sm px-2 py-1 shadow-sm transition-all duration-200 border
                ${snapshot.isDragging ? "shadow-lg" : ""}
                ${isOverdue && isInTimeline ? "animate-blink" : ""}
                ${isDuplicate && !isInTimeline ? "animate-blink-yellow" : ""}
                hover:shadow-md cursor-pointer
                flex-shrink-0 relative
              `}
              style={{
                ...provided.draggableProps.style,
                width: cardWidth,
                minHeight: "40px",
                // evidenziamo sulla mappa ma SENZA deformare la hitbox durante il drag
                ...(isMapFiltered && !snapshot.isDragging ? {
                  boxShadow: '0 0 0 3px #3B82F6, 0 0 20px 5px rgba(59, 130, 246, 0.5)',
                  transform: 'scale(1.05)',
                  zIndex: 10,
                } : {})
              }}

Effetto:
Niente scale-105 durante il drag ‚Üí la dimensione visiva e la hitbox restano coerenti.


Se la task √® evidenziata sulla mappa, scala solo quando non stai trascinando.



2. Evidenziare solo la zona di drop (non tutta la riga)
2.1. Rimuovere l‚Äôhighlight di tutta la riga
File: client/src/components/timeline/timeline-view.tsx
Cerca il Droppable principale della timeline del cleaner:
<Droppable droppableId={`timeline-${cleaner.id}`} direction="horizontal" isDropDisabled={isReadOnly}>
  {(provided, snapshot) => (
    <div
      ref={provided.innerRef}
      {...provided.droppableProps}
      data-testid={`timeline-cleaner-${cleaner.id}`}
      data-cleaner-id={cleaner.id}
      className={`relative min-h-[45px] flex-1 border-l border-border ${
        snapshot.isDraggingOver && !isReadOnly ? 'bg-primary/20 ring-2 ring-primary' : 'bg-background'
      }`}
      style={{
        zIndex: filteredCleanerId === cleaner.id || hasIncompatibleTasks ? 15 : 'auto'
      }}
    >

Sostituisci solo il className con una versione ‚Äúneutra‚Äù:
     className="relative min-h-[45px] flex-1 border-l border-border bg-background"

Il resto del componente resta uguale.
2.2. Usare la placeholder come highlight della zona di drop
File: client/src/index.css
In fondo al file (o comunque in una zona globale), aggiungi:
/* Evidenziazione precisa della zona di drop nella timeline */
[data-testid^="timeline-cleaner-"] .react-beautiful-dnd-placeholder {
  background-color: hsl(221.2 83.2% 53.3% / 0.25); /* primary con opacit√† */
  border-radius: 4px;
  pointer-events: none;
}

react-beautiful-dnd usa di default la classe .react-beautiful-dnd-placeholder, quindi cos√¨ crei un ‚Äúblocco‚Äù colorato esattamente dove cadrebbe la task (stessa larghezza/durata), senza colorare l‚Äôintera riga.

3. Tooltip con il numero di sequenza mentre trascini
Useremo onDragUpdate del DragDropContext per sapere in tempo reale destination.index e lo mostreremo in un piccolo overlay fisso.
3.1. Stato per il preview
File: client/src/pages/generate-assignments.tsx
Dopo:
 // Stato per tracciare se √® in corso un'operazione di drag-and-drop
  const [isDragging, setIsDragging] = useState<boolean>(false);

aggiungi:
 // Preview della posizione di sequenza mentre trascini
  const [dragSequencePreview, setDragSequencePreview] = useState<{ sequenceIndex: number } | null>(null);

3.2. Handler onDragUpdate e reset del preview
Nella stessa pagina, vicino a parseCleanerId e a onDragEnd, aggiungi:
 const onDragUpdate = (update: any) => {
    const { destination } = update;

    if (!destination) {
      setDragSequencePreview(null);
      return;
    }

    const toCleanerId = parseCleanerId(destination.droppableId);

    // Mostriamo il numero di sequenza solo quando siamo sulla timeline di un cleaner
    if (toCleanerId === null) {
      setDragSequencePreview(null);
      return;
    }

    setDragSequencePreview({
      // index √® 0-based, mostrato come 1-based
      sequenceIndex: destination.index + 1,
    });
  };

All‚Äôinizio di onDragEnd, aggiungi una riga per pulire il preview:
 const onDragEnd = async (result: any) => {
    setDragSequencePreview(null);

    const { destination, source, draggableId } = result;
    ...

(Se in futuro vuoi anche un onDragStart, ti basta fare un setDragSequencePreview(null) l√¨.)
3.3. Collegare onDragUpdate al DragDropContext
Cerca il componente:
<DragDropContext onDragEnd={onDragEnd}>

Sostituiscilo con:
<DragDropContext
  onDragEnd={onDragEnd}
  onDragUpdate={onDragUpdate}
>

3.4. Overlay del tooltip in basso a destra
Sempre in GenerateAssignments, verso la fine del JSX (subito prima di </DragDropContext>), aggiungi:
       {dragSequencePreview && (
          <div className="fixed bottom-4 right-4 z-[9999] bg-slate-900 text-white text-xs px-3 py-2 rounded shadow-lg pointer-events-none">
            <span className="opacity-80 mr-1">Posizione nella sequenza:</span>
            <span className="font-semibold">
              {dragSequencePreview.sequenceIndex}
            </span>
          </div>
        )}
        </DragDropContext>

(Attenzione a non duplicare </DragDropContext>: sostituisci la chiusura esistente con la versione che include il blocco sopra.)
Risultato: mentre trascini sopra la timeline di un cleaner, vedi in basso a destra un piccolo tooltip con ‚ÄúPosizione nella sequenza: N‚Äù.

4. Caricamento in background quando sposti una task
Ora onDragEnd fa un refreshAssignments("manual"), che oggi mostra il loader globale. Modifichiamo refreshAssignments per non usare lo spinner quando il trigger √® "manual".
File: client/src/pages/generate-assignments.tsx
Cerca:
 const refreshAssignments = async (
    trigger: "initial" | "date-change" | "manual" | "manual-refresh",
    date: Date = selectedDate
  ) => {
    console.log(`üîÑ refreshAssignments chiamato con trigger: "${trigger}"`);
    setIsLoading(true);

    try {
      if (trigger === "manual" || trigger === "manual-refresh") {
        // Refresh manuale dopo drag-and-drop: solo reload file, NO auto-load, NO extractData
        console.log('üìÇ Refresh manuale - solo reload file JSON (preserva timeline.json)');
        await loadTasks(true);
        return;
      }

      // Per initial e date-change, esegui auto-load completo
      await checkAndAutoLoadSavedAssignments(date);
    } catch (error) {
      console.error("Errore durante refreshAssignments:", error);
    } finally {
      setIsLoading(false);
    }
  };

Sostituiscilo con:
 const refreshAssignments = async (
    trigger: "initial" | "date-change" | "manual" | "manual-refresh",
    date: Date = selectedDate
  ) => {
    console.log(`üîÑ refreshAssignments chiamato con trigger: "${trigger}"`);

    // Mostra il loader globale solo quando serve davvero
    const shouldShowGlobalLoader =
      trigger === "initial" ||
      trigger === "date-change" ||
      trigger === "manual-refresh";

    if (shouldShowGlobalLoader) {
      setIsLoading(true);
    }

    try {
      if (trigger === "manual" || trigger === "manual-refresh") {
        // Refresh manuale dopo drag-and-drop: solo reload file, NO auto-load, NO extractData
        console.log('üìÇ Refresh manuale - solo reload file JSON (preserva timeline.json)');
        await loadTasks(true);
        return;
      }

      // Per initial e date-change, esegui auto-load completo
      await checkAndAutoLoadSavedAssignments(date);
    } catch (error) {
      console.error("Errore durante refreshAssignments:", error);
    } finally {
      if (shouldShowGlobalLoader) {
        setIsLoading(false);
      }
    }
  };

Ora:
refreshAssignments("initial") / "date-change" / "manual-refresh" continuano a mostrare lo spinner.


refreshAssignments("manual") (usato dal drag & drop) ricarica i dati in background, senza bloccare la UI.