Devi implementare FASE 2 (Selezione cleaner ideale) nel progetto Node/TS già esistente, in modo shadow: devi SOLO leggere da tabelle di produzione e scrivere solo su schema optimizer (decision log), senza modificare in alcun modo le assegnazioni reali.

Contesto

FASE 1 è già implementata e salva:

optimizer.optimizer_run (una run per data)

optimizer.optimizer_decision con eventi PHASE1_GROUP_CANDIDATE (payload include gruppi 2/3/4 + single, score, travel, zone)

Ora FASE 2 deve:

prendere i gruppi candidati generati da FASE 1

caricare tasks + cleaners del giorno read-only (tabelle di produzione)

assegnare ogni gruppo a un cleaner compatibile con uno scoring

salvare tutto come decision log su optimizer.optimizer_decision (fase=2)

Requisiti funzionali

Input

date (YYYY-MM-DD)

runId opzionale (se non passato, usa l’ultima run FASE1 per quella data)

Caricamenti (read-only da produzione)

tasks del giorno (quelle su cui FASE1 ha lavorato)

cleaners disponibili del giorno

per ogni cleaner: capability/skill (Standard/Premium/Straordinaria), tipo apt A/B/C, eventuali preferenze/priorità (EO/HP/LP come peso soft)

Compatibilità
Un cleaner è compatibile con un task se:

può fare quel tipo servizio (Standard/Premium/Straordinaria)

può fare quel tipo apt (A/B/C)
Le priorità EO/HP/LP NON bloccano, sono solo un peso nello score.

Algoritmo

ordina i gruppi candidati per score decrescente (come da FASE1)

per ogni gruppo:

trova lista cleaners compatibili con TUTTE le task del gruppo

calcola uno score per ogni cleaner:

travel stimato: distanza (o travel time se disponibile) dal “punto di partenza” del cleaner al primo task del gruppo

punto di partenza = ultima task già assegnata a quel cleaner in questa run (se esiste), altrimenti usa solo distanza dal primo task e considera travel=0 (o home base se esiste nel db)

carico corrente: quante task sono già state assegnate a quel cleaner in questa run (penalizza chi ha già carico)

preferenze/priorità (bonus/peso soft)

seleziona il cleaner col punteggio migliore e assegna il gruppo

se NON trovi cleaner compatibile:

se gruppo ha più di 1 task:

rimuovi la task “più costosa” (quella che aumenta di più travel o che riduce compatibilità) e riprova (loop finché resta 1 task)

ogni drop deve essere loggato

se gruppo diventa single e ancora non assegnabile:

mettilo in “unassigned candidate” (la decisione finale è FASE3)

Cosa salvare (solo decision log)
Scrivere su optimizer.optimizer_decision eventi (tutti con run_id, phase=2, timestamp):

PHASE2_CLEANER_CANDIDATE (per i top N cleaner valutati: include score breakdown)

PHASE2_CLEANER_REJECT (se scartato per incompatibilità: include reason)

PHASE2_GROUP_ASSIGNED (gruppo -> cleaner scelto)

PHASE2_TASK_DROPPED (task rimossa dal gruppo con reason e retry_count)

PHASE2_GROUP_UNASSIGNED_CANDIDATE (single o gruppo non assegnabile)

NON scrivere su tabelle di produzione, NON creare assegnazioni finali.

Endpoint/API
Aggiungi endpoint:

POST /api/optimizer/run-phase2
Body: { "date": "YYYY-MM-DD", "runId": "..."? }
Response: { runId, assignedGroups, droppedTasks, unassignedGroups }

Struttura codice
Crea (o usa) questi file:

server/services/optimizer/phase2.ts (core algoritmo)

server/services/optimizer/runPhase2.ts (orchestrazione: load data, call phase2, persist decisions)

server/routes/optimizer.ts (aggiungi route run-phase2)
Riusa lo stile di FASE1: separa logica e DB.

DB access
Usa lo stesso client PG già presente nel progetto.
Non cambiare schema produzione.
Se devi aggiungere indici o tabelle, SOLO su schema optimizer (ma idealmente FASE2 non richiede nuove tabelle oltre optimizer_run/decision).

Output e test

aggiungi log server-side chiari

aggiungi almeno 1 test minimale (o uno script) che esegue run-phase2 su una data e verifica che siano stati scritti eventi phase=2 in optimizer.optimizer_decision.

Vincolo fondamentale

Questa fase deve essere completamente “parallel/shadow”. L’unico side-effect consentito è scrivere su schema optimizer.