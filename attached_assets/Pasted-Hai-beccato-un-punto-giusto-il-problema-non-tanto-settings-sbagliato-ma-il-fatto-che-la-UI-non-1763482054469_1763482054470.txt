Hai beccato un punto giusto: il problema non Ã¨ tanto â€œsettings sbagliatoâ€, ma il fatto che la UI non passa correttamente can_do_straordinaria al validatore, quindi taskValidation.ts finisce per considerare sempre false quel flag.

In piÃ¹, nel validatore câ€™Ã¨ anche un bug sul nome della chiave del ruolo.

Ti riassumo cosa ho visto nello zip TaskFlowMaster (4).zip e poi ti do i patch da incollare.

ğŸ” Cosa succede oggi
1. Il validatore TS (taskValidation.ts)

La funzione chiave Ã¨:

export function canCleanerHandleTaskSync(
  cleanerRole: string,
  task: any,
  rules: ValidationRules | null,
  canDoStraordinaria: boolean = false
): boolean {
  if (!rules) return true;

  const taskType = determineTaskType(task);
  if (!taskType) return true;

  // Per straordinarie, usa il flag can_do_straordinaria del cleaner
  if (taskType === 'straordinario_apt') {
    return canDoStraordinaria;
  }

  const normalizedRole = normalizeCleanerRole(cleanerRole);
  const roleKey = `${normalizedRole}_cleaner`;

  const taskRules = rules.task_types?.[taskType];
  if (!taskRules) return true;

  return taskRules[roleKey] ?? false;
}


Problemi:

canDoStraordinaria viene sempre passato come default false perchÃ© la UI non lo passa mai â†’ tutte le straordinarie vengono viste come non compatibili (a meno che sia un ruolo â€œStraordinaria Cleanerâ€ dedicato).

normalizeCleanerRole ritorna giÃ  una chiave tipo "premium_cleaner", "formatore_cleaner", ecc.
Ma poi fai:

const roleKey = `${normalizedRole}_cleaner`;


â†’ diventa "premium_cleaner_cleaner" â†’ chiave inesistente in task_types â†’ il validatore torna false per tutte le task non straordinarie.
(Te ne accorgi meno solo perchÃ© ignori alcuni warning / li acki).

2. Come viene chiamato dalla UI

In timeline-view.tsx lo usi cosÃ¬ (esempio):

const incompatibleTasks = cleanerTasks.filter(task => {
  if (canCleanerHandleTaskSync(cleaner.role, task, validationRules)) return false;
  const key = getIncompatibleKey(task, cleaner.id);
  return !acknowledgedIncompatibleAssignments.has(key);
});


ma non passi mai il flag cleaner.can_do_straordinaria, anche se il tipo Cleaner ce lâ€™ha:

interface Cleaner {
  ...
  can_do_straordinaria?: boolean;
}


Per JOHOISER infatti nei dati:

{
  "name": "JOHOISER ERNESTO",
  "lastname": "LOPEZ GIRON",
  "role": "Premium",
  ...
  "can_do_straordinaria": true
}


ma il validatore riceve sempre canDoStraordinaria = false â†’ quindi la sua straordinaria (Task 117) viene marcata incompatibile.

âœ… Fix 1 â€“ Correggere taskValidation.ts (ruolo + uso flag)

File: client/src/lib/taskValidation.ts

Sostituisci la funzione canCleanerHandleTaskSync con questa:

export function canCleanerHandleTaskSync(
  cleanerRole: string,
  task: any,
  rules: ValidationRules | null,
  canDoStraordinaria: boolean = false
): boolean {
  if (!rules) return true;

  const taskType = determineTaskType(task);
  if (!taskType) return true;

  // Per straordinarie, usa il flag can_do_straordinaria del cleaner
  if (taskType === 'straordinario_apt') {
    return canDoStraordinaria;
  }

  const normalizedRole = normalizeCleanerRole(cleanerRole);
  // FIX: normalizedRole Ã¨ giÃ  una chiave di TaskTypeRules (es. "premium_cleaner")
  const roleKey: keyof TaskTypeRules = normalizedRole;

  const taskRules = rules.task_types?.[taskType];
  if (!taskRules) return true;

  return taskRules[roleKey] ?? false;
}


Il resto del file puÃ² rimanere uguale (la parte async canCleanerHandleTask Ã¨ giÃ  ok: passa il flag cleanerData?.can_do_straordinaria).

âœ… Fix 2 â€“ Passare can_do_straordinaria dalla UI

File: client/src/components/timeline/timeline-view.tsx

Ovunque chiami:

canCleanerHandleTaskSync(cleaner.role, task, validationRules)


devi passare anche il quarto argomento:

canCleanerHandleTaskSync(cleaner.role, task, validationRules, cleaner.can_do_straordinaria ?? false)


Nel codice attuale ci sono 5 punti:

1ï¸âƒ£ Primo click sul cleaner â†’ dialog incompatibilitÃ :

const incompatibleTasks = cleanerTasks.filter(task => {
  if (canCleanerHandleTaskSync(cleaner.role, task, validationRules)) return false;
  ...
});


â¡ï¸ Cambia in:

const incompatibleTasks = cleanerTasks.filter(task => {
  if (canCleanerHandleTaskSync(cleaner.role, task, validationRules, cleaner.can_do_straordinaria ?? false)) return false;
  const key = getIncompatibleKey(task, cleaner.id);
  return !acknowledgedIncompatibleAssignments.has(key);
});


2ï¸âƒ£ Effetto che mostra i toast â€œassegnazione incompatibileâ€:

const incompatibleTasks = cleanerTasks.filter(task => {
  if (canCleanerHandleTaskSync(cleaner.role, task, validationRules)) return false;
  ...
});


â¡ï¸ Cambia in:

const incompatibleTasks = cleanerTasks.filter(task => {
  if (canCleanerHandleTaskSync(cleaner.role, task, validationRules, cleaner.can_do_straordinaria ?? false)) return false;
  const key = getIncompatibleKey(task, cleaner.id);
  return !acknowledgedIncompatibleAssignments.has(key);
});


3ï¸âƒ£ Check se un cleaner ha task incompatibili per colorare la card:

const hasIncompatibleTasks = validationRules && cleaner?.role
  ? cleanerTasks.some(task => {
      if (canCleanerHandleTaskSync(cleaner.role, task, validationRules)) return false;
      ...
    })
  : false;


â¡ï¸ Cambia in:

const hasIncompatibleTasks = validationRules && cleaner?.role
  ? cleanerTasks.some(task => {
      if (canCleanerHandleTaskSync(cleaner.role, task, validationRules, cleaner.can_do_straordinaria ?? false)) return false;
      const key = getIncompatibleKey(task, cleaner.id);
      return !acknowledgedIncompatibleAssignments.has(key);
    })
  : false;


4ï¸âƒ£ Dentro il render della timeline, quando calcoli isIncompatible per la singola task:

const isIncompatible = validationRules && cleaner?.role
  ? !canCleanerHandleTaskSync(cleaner.role, task, validationRules)
  : false;


â¡ï¸ Cambia in:

const isIncompatible = validationRules && cleaner?.role
  ? !canCleanerHandleTaskSync(cleaner.role, task, validationRules, cleaner.can_do_straordinaria ?? false)
  : false;


5ï¸âƒ£ Quando fai â€œHo capitoâ€ e marchi tutte le incompatibili come ackate:

cleanerTasks.forEach(task => {
  if (!canCleanerHandleTaskSync(cleaner.role, task, validationRules)) {
    const key = getIncompatibleKey(task, cleanerId);
    next.add(key);
  }
});


â¡ï¸ Cambia in:

cleanerTasks.forEach(task => {
  if (!canCleanerHandleTaskSync(cleaner.role, task, validationRules, cleaner.can_do_straordinaria ?? false)) {
    const key = getIncompatibleKey(task, cleanerId);
    next.add(key);
  }
});

ğŸ”š Dopo questi fix, cosa cambia per JOHOISER

Per JOHOISER:

ruolo: "Premium"

can_do_straordinaria: true

Task 117: straordinaria: true

Il flusso diventa:

getTaskType(task) â†’ 'straordinario_apt'

canCleanerHandleTaskSync("Premium", task, rules, true):

taskType === 'straordinario_apt' â†’ ritorna direttamente canDoStraordinaria â†’ true

isIncompatibleAssignment / controllo nellâ€™interfaccia vedono la task come compatibile â†’ niente warning nella modale â€œâš ï¸ Task Incompatibiliâ€ per quella task.

Se invece prendi un Premium senza can_do_straordinaria (o false), allora la straordinaria continuerÃ  ad essere segnalata correttamente come incompatibile.