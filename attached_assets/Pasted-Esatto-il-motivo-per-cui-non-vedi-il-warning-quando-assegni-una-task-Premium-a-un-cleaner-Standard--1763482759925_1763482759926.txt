Esatto, il motivo per cui non vedi il warning quando assegni una task Premium a un cleaner Standard Ã¨ che il validatore canCleanerHandleTaskSync Ã¨ buggato: al momento ritorna quasi sempre true (tutto compatibile) per i casi non-straordinari, perchÃ©:

Usa una struttura rules.task_types[...] che non esiste (le regole sono giÃ  lâ€™oggetto interno).

Per i ruoli costruisce una chiave sbagliata tipo "premium_cleaner_cleaner".

Ti lascio i fix concreti da applicare, cosÃ¬:

il Premiumâ†’Standard viene segnalato come incompatibile âœ…

il flag can_do_straordinaria funziona anche in drag&drop âœ…

1ï¸âƒ£ Fix in taskValidation.ts

File: client/src/lib/taskValidation.ts

1.1. Sistema il tipo ValidationRules e cachedRules

In alto ora hai:

interface ValidationRules {
  task_types: {
    standard_apt: TaskTypeRules;
    premium_apt: TaskTypeRules;
    straordinario_apt: TaskTypeRules;
  };
}

let cachedRules: TaskValidationSettings['task_types'] | null = null;


ğŸ”§ Sostituisci con:

// Le regole che usiamo sono direttamente la mappa task_types di settings.json
type ValidationRules = TaskValidationSettings["task_types"];

let cachedRules: ValidationRules | null = null;


(il resto sopra puÃ² restare uguale)

1.2. Correggi canCleanerHandleTaskSync

Ora Ã¨ cosÃ¬:

export function canCleanerHandleTaskSync(
  cleanerRole: string,
  task: any,
  rules: ValidationRules | null,
  canDoStraordinaria: boolean = false
): boolean {
  if (!rules) return true;

  const taskType = determineTaskType(task);
  if (!taskType) return true;

  // Per straordinarie, usa il flag can_do_straordinaria del cleaner
  if (taskType === 'straordinario_apt') {
    return canDoStraordinaria;
  }

  const normalizedRole = normalizeCleanerRole(cleanerRole);
  const roleKey = `${normalizedRole}_cleaner`;

  const taskRules = rules.task_types?.[taskType];
  if (!taskRules) return true;

  return taskRules[roleKey] ?? false;
}


ğŸ”§ Sostituiscilo con:

export function canCleanerHandleTaskSync(
  cleanerRole: string,
  task: any,
  rules: ValidationRules | null,
  canDoStraordinaria: boolean = false
): boolean {
  if (!rules) return true;

  const taskType = determineTaskType(task);
  if (!taskType) return true;

  // Per straordinarie, usa il flag can_do_straordinaria del cleaner
  if (taskType === "straordinario_apt") {
    return canDoStraordinaria;
  }

  const normalizedRole = normalizeCleanerRole(cleanerRole);
  // normalizedRole Ã¨ giÃ  "standard_cleaner" | "premium_cleaner" | ...
  const roleKey: keyof TaskTypeRules = normalizedRole;

  // rules Ã¨ direttamente settings.task_types
  const taskRules = rules[taskType];
  if (!taskRules) return true;

  return taskRules[roleKey] ?? false;
}


Con questo:

rules Ã¨ lâ€™oggetto { standard_apt: {...}, premium_apt: {...}, ... } preso da settings.task_types.

taskRules per una Premium diventa rules["premium_apt"].

roleKey per Standard diventa "standard_cleaner", quindi:

se premium_apt.standard_cleaner === false in settings.json â†’ viene segnalato come incompatibile âœ…

2ï¸âƒ£ Fix in timeline-view.tsx: passare can_do_straordinaria

FinchÃ© non passi il flag, tutte le straordinarie risultano incompatibili anche per i Premium che potrebbero farle.

File: client/src/components/timeline/timeline-view.tsx

Cerca tutti i punti dove chiami:

canCleanerHandleTaskSync(cleaner.role, task, validationRules)


e aggiungi il 4Âº argomento:

canCleanerHandleTaskSync(
  cleaner.role,
  task,
  validationRules,
  cleaner.can_do_straordinaria ?? false
)


In questa versione del file li vedo in 5 punti:

1ï¸âƒ£ Primo click sul cleaner (dialog incompatibilitÃ ):

const incompatibleTasks = cleanerTasks.filter(task => {
  if (canCleanerHandleTaskSync(cleaner.role, task, validationRules)) return false;
  const key = getIncompatibleKey(task, cleaner.id);
  return !acknowledgedIncompatibleAssignments.has(key);
});


â¡ï¸ diventa:

const incompatibleTasks = cleanerTasks.filter(task => {
  if (canCleanerHandleTaskSync(
    cleaner.role,
    task,
    validationRules,
    cleaner.can_do_straordinaria ?? false
  )) return false;
  const key = getIncompatibleKey(task, cleaner.id);
  return !acknowledgedIncompatibleAssignments.has(key);
});


2ï¸âƒ£ Effetto che costruisce la lista di cleaner con task incompatibili:

const incompatibleTasks = cleanerTasks.filter(task => {
  if (canCleanerHandleTaskSync(cleaner.role, task, validationRules)) return false;
  ...
});


â¡ï¸ stesso cambio:

if (canCleanerHandleTaskSync(
  cleaner.role,
  task,
  validationRules,
  cleaner.can_do_straordinaria ?? false
)) return false;


3ï¸âƒ£ Calcolo hasIncompatibleTasks per colorare la colonna cleaner:

const hasIncompatibleTasks = validationRules && cleaner?.role
  ? cleanerTasks.some(task => {
      if (canCleanerHandleTaskSync(cleaner.role, task, validationRules)) return false;
      const key = getIncompatibleKey(task, cleaner.id);
      return !acknowledgedIncompatibleAssignments.has(key);
    })
  : false;


â¡ï¸ diventa:

const hasIncompatibleTasks = validationRules && cleaner?.role
  ? cleanerTasks.some(task => {
      if (canCleanerHandleTaskSync(
        cleaner.role,
        task,
        validationRules,
        cleaner.can_do_straordinaria ?? false
      )) return false;
      const key = getIncompatibleKey(task, cleaner.id);
      return !acknowledgedIncompatibleAssignments.has(key);
    })
  : false;


4ï¸âƒ£ Verifica inline per singola task nella timeline:

const isIncompatible = validationRules && cleaner?.role
  ? !canCleanerHandleTaskSync(cleaner.role, task, validationRules)
  : false;


â¡ï¸ diventa:

const isIncompatible = validationRules && cleaner?.role
  ? !canCleanerHandleTaskSync(
      cleaner.role,
      task,
      validationRules,
      cleaner.can_do_straordinaria ?? false
    )
  : false;


5ï¸âƒ£ Quando clicchi â€œHo capitoâ€ e marchi le incompatibili come ackate:

cleanerTasks.forEach(task => {
  if (!canCleanerHandleTaskSync(cleaner.role, task, validationRules)) {
    const key = getIncompatibleKey(task, cleanerId);
    next.add(key);
  }
});


â¡ï¸ diventa:

cleanerTasks.forEach(task => {
  if (!canCleanerHandleTaskSync(
    cleaner.role,
    task,
    validationRules,
    cleaner.can_do_straordinaria ?? false
  )) {
    const key = getIncompatibleKey(task, cleanerId);
    next.add(key);
  }
});

ğŸ”š Effetto finale

Dopo questi fix:

Task Premium â†’ Cleaner Standard

taskType = 'premium_apt'

normalizedRole = 'standard_cleaner'

taskRules = rules["premium_apt"]

se in settings.json hai "standard_cleaner": false in premium_apt,
il drag&drop e la modale â€œâš ï¸ Task Incompatibiliâ€ segnaleranno correttamente lâ€™incompatibilitÃ .

Task Straordinaria â†’ Cleaner Premium con can_do_straordinaria: true

viene considerata compatibile, niente warning.

Task Straordinaria â†’ Cleaner Premium con can_do_straordinaria: false (o assente)

viene segnalata incompatibile.