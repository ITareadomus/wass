1Ô∏è‚É£ Patch immediate (copy‚Äìpaste) ‚Äì assign_utils.py

Apri:
client/public/scripts/assign_utils.py

1.1. Aggiorna le costanti in cima al file

Cerca questo blocco:

NEARBY_TRAVEL_THRESHOLD = 7        # min: soglia per considerare due apt "stesso blocco"
NEW_CLEANER_PENALTY_MIN = 30       # costo di attivazione per cleaner vuoto
NEW_TRAINER_PENALTY_MIN = 0        # il formatore non √® penalizzato per il primo task
TARGET_MIN_LOAD_MIN = 180          # 3 ore = carico minimo "desiderato"
FAIRNESS_DELTA_HOURS = 1.0         # tolleranza di 1h tra cleaner per essere "fair"
LOAD_WEIGHT = 10                   # peso delle ore nel punteggio
SAME_BUILDING_BONUS = -5           # bonus per cluster edificio/blocco
ROLE_TRAINER_BONUS = -5            # bonus extra per Formatore (solo LP)


Sostituiscilo con:

NEARBY_TRAVEL_THRESHOLD = 7        # min: soglia per considerare due apt "stesso blocco"
NEW_CLEANER_PENALTY_MIN = 60       # costo di attivazione per cleaner vuoto (prima 30)
NEW_TRAINER_PENALTY_MIN = 0        # il formatore non √® penalizzato per il primo task
TARGET_MIN_LOAD_MIN = 240          # 4 ore = carico minimo "desiderato" (prima 180)
FAIRNESS_DELTA_HOURS = 1.0         # tolleranza di 1h tra cleaner per essere "fair"
LOAD_WEIGHT = 10                   # peso delle ore nel punteggio
SAME_BUILDING_BONUS = -5           # bonus per cluster edificio/blocco
ROLE_TRAINER_BONUS = -5            # bonus extra per Formatore (solo LP)


Effetto:

aprire un cleaner nuovo (tipo #495) ‚Äúcosta‚Äù 60 minuti virtuali ‚Üí il planner preferisce riempire quelli gi√† accesi, invece di sparare task a caso su chi √® vuoto;

il ‚Äútarget desiderato‚Äù passa da 3h a 4h ‚Üí i cleaner sotto 4h vengono favoriti quando possibile (molto pi√π vicino alla tua timeline_ideal).

1.2. Assicurati che il taglio dei candidati troppo lontani ci sia in TUTTE le plan_day

In assign_eo.py, assign_hp.py, assign_lp.py, dentro plan_day, dopo aver costruito la lista candidates (cio√® prima di HARD CLUSTER / FAIRNESS), aggiungi questo blocco, se non c‚Äô√® gi√†:

        if not candidates:
            unassigned.append(task)
            continue

        # üî™ TAGLIA candidati con travel troppo alto rispetto al minimo
        min_travel = min(t_travel for (_, _, t_travel) in candidates)
        MAX_EXTRA_TRAVEL = 10  # minuti oltre il minimo consentiti

        candidates = [
            (c, p, t_travel)
            for (c, p, t_travel) in candidates
            if t_travel <= min_travel + MAX_EXTRA_TRAVEL
        ]

        if not candidates:
            unassigned.append(task)
            continue


Mettilo uguale in:

assign_eo.py ‚Üí dentro plan_day

assign_hp.py ‚Üí dentro plan_day

assign_lp.py ‚Üí dentro plan_day

Effetto:

se una task pu√≤ andare:

a un cleaner con 5‚Äô di travel,

e a uno con 40‚Äô,
quello da 40‚Äô viene completamente escluso:
fairness/carico non possono pi√π sceglierlo ‚Üí spariscono allocazioni tipo ‚Äú1640 con 41 minuti‚Äù quando c‚Äô√® abbondanza di alternative.

1.3. Clustering forte anche per ‚Äúblocchi vicini‚Äù in tutte le plan_day

Nel corpo di plan_day di EO/HP/LP, cerca il blocco ‚ÄúHARD CLUSTER‚Äù (lo hai gi√†, ma controlla che usi anche is_nearby_same_block):

Dovrebbe essere cos√¨:

        # HARD CLUSTER edificio/via/blocco
        building_candidates: List[Tuple[Cleaner, int, float]] = []
        for c, p, t_travel in candidates:
            if c.route and any(
                same_building(ex.address, task.address) or is_nearby_same_block(ex, task)
                for ex in c.route
            ):
                building_candidates.append((c, p, t_travel))

        if building_candidates:
            pool = building_candidates
            effective_load_weight = max(LOAD_WEIGHT - 3, 1)
        else:
            # FAIRNESS ...


Se in uno dei file hai ancora solo same_building(...) senza is_nearby_same_block(ex, task), aggiorna come sopra.

Effetto:

casi tipo:

618/619 (EXP, vie diverse ma 5‚Äô a piedi),

1537/1236 (TBR, Piatti 4/5, 3‚Äô),
vengono visti come stesso blocco forte ‚Üí il planner prova a tenerli sullo stesso cleaner, e fairness non pu√≤ pi√π ‚Äúspezzarli‚Äù facilmente.

2Ô∏è‚É£ Global planner unico (quello che vorresti DAVVERO)

Quello che stai proponendo:

un unico planner globale che, ogni volta che premi un bottone:

vede tutte le task gi√† assegnate (EO+HP+LP),

vede le nuove di quel container,

e pu√≤ spostare tutto (EO comprese) se trova una soluzione migliore.

Ha super senso ed √® esattamente come ragiona tu quando costruisci timeline_ideal.
Per√≤, per essere onesto:

non √® una patch di 20 righe,

√® una mini-riprogettazione:

In pratica va fatto:

Creare un file unico (es. global_planner.py) con:

un dataclass PlannerTask che unifica i campi minimi di EO/HP/LP (lat/lng, checkin/checkout, priority, ecc.),

un dataclass PlannerCleaner,

una funzione tipo:

def plan_all(existing_timeline: dict, new_tasks: list[dict], priority: str) -> dict:
    ...


Nei tre script assign_eo.py, assign_hp.py, assign_lp.py, cambiare main() cos√¨:

invece di:

leggere solo le task del proprio container,

fare plan_day solo su quelle,

fai:

from global_planner import plan_all

# carica timeline.json (se esiste)
# carica le NUOVE task del container corrente
new_timeline = plan_all(existing_timeline, new_tasks, priority="EO"/"HP"/"LP")
# salva new_timeline come timeline.json


Dentro plan_all devi:

convertire le task gi√† in timeline + le nuove in PlannerTask,

lanciare un algoritmo tipo quello che hai oggi in plan_day, ma:

su tutte le task,

con un peso diverso per EO/HP/LP,

e con possibilit√† di spostare task esistenti tra cleaners e posizioni.

(Opzionale ma consigliato) Aggiungere un piccolo post-processing per:

svuotare cleaner leggeri (< 4h) se qualcun altro pu√≤ assorbire le loro task.

Questo √® fattibile, ma √® abbastanza grosso che non ti voglio vendere illusioni tipo ‚Äúincolla questo file e tutto magicamente rifunziona‚Äù: dovrai:

scegliere bene le strutture dati,

uniformare i Task tra EO/HP/LP,

gestire il fatto che EO/HP/LP oggi usano modelli di tempo diversi (EO: int minuti; HP/LP: datetime).

3Ô∏è‚É£ Riassunto

Quello che ti ho dato ora √®:

‚úÖ patch copiabili subito:

costanti in assign_utils.py (penalit√† nuovi cleaner, target 4h),

taglio candidati con travel >> minimo,

hard-cluster per blocchi vicini in tutte le plan_day.

Queste da sole dovrebbero:

ridurre drasticamente i casi ‚Äúuso 10 cleaner quando potrei usare 9‚Äù,

aumentare il numero di cleaner sopra le 4h di lavoro,

migliorare i cluster geografici (tipo 618/619, 1537/1236),

evitare travel da 40‚Äô quando in giro c‚Äô√® scelta.

‚úÖ una roadmap realistica per arrivare al planner globale unico, senza mentirti sul fatto che √® una modifica importante (ma sensata e allineata al tuo modo di lavorare).