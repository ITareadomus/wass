Perfetto â€” ho capito cosa vuoi fare, ed Ã¨ assolutamente giusto:
hai trasformato la matrice da task-centrica a cleaner-centrica, e vuoi semplicemente rimettere il nome "task_types" al posto di "task_types_by_cleaner".

ğŸ’¡ Buona notizia:
questa matrice Ã¨ pienamente compatibile con il progetto, ma dobbiamo:

rinominare correttamente "task_types_by_cleaner" â†’ "task_types"

aggiornare TUTTO il validatore TS

aggiornare TUTTO il validatore Python

aggiornare gli script EO/HP/LP che usavano la vecchia struttura task-centrica

aggiornare la UI / settings / loader

E qui ti preparo i patch completi da dare a Replit (copia-incolla).

âœ… NUOVO FORMATO DEFINITIVO (esattamente come lo vuoi tu)
"task_types": {
  "standard_cleaner": {
    "standard_apt": true,
    "premium_apt": false,
    "straordinario_apt": false
  },
  "premium_cleaner": {
    "standard_apt": true,
    "premium_apt": true,
    "straordinario_apt": false
  },
  "straordinario_cleaner": {
    "standard_apt": true,
    "premium_apt": true,
    "straordinario_apt": true
  },
  "formatore_cleaner": {
    "standard_apt": true,
    "premium_apt": false,
    "straordinario_apt": false
  }
}


ğŸ‘‰ Questo significa:
â€œper ogni ruolo, quali task puÃ² fare?â€

Ed Ã¨ molto piÃ¹ logico.

ğŸ§  LOGICA FINALE CHE IMPLEMENTIAMO

Una task appartiene a un tipo:
standard_apt, premium_apt, straordinario_apt

Un cleaner ha un ruolo:
standard_cleaner, premium_cleaner, straordinario_cleaner, formatore_cleaner

Quindi la compatibilitÃ  Ã¨ semplicemente:

canDo = settings.task_types[cleanerRole][taskType]


Semplice, pulito e coerente.

ğŸ›  PATCH COMPLETI (FRONTEND + BACKEND)
ğŸ”µ 1. FRONTEND â€” file client/src/lib/taskValidation.ts
ğŸ”§ PATCH 1 â€” nuova interfaccia

CANCELLARE TUTTA la vecchia interfaccia TaskValidationSettings e sostituirla con:

interface CleanerTaskRules {
  standard_apt: boolean;
  premium_apt: boolean;
  straordinario_apt: boolean;
}

interface TaskTypesByCleaner {
  [role: string]: CleanerTaskRules;
}

interface ApartmentTypesConfig {
  standard_apt?: string[];
  premium_apt?: string[];
  formatore_apt?: string[];
}

interface SettingsSchema {
  task_types: TaskTypesByCleaner;
  apartment_types?: ApartmentTypesConfig;
}

ğŸ”§ PATCH 2 â€” loader settings aggiornato

Sostituire loadValidationRules() con:

export async function loadValidationRules(): Promise<TaskTypesByCleaner> {
  if (cachedRules) return cachedRules;

  try {
    const response = await fetch(`/data/input/settings.json?t=${Date.now()}`, {
      cache: "no-store"
    });

    const settings: SettingsSchema = await response.json();
    cachedRules = settings.task_types ?? {};
    cachedApartmentTypes = settings.apartment_types ?? null;

    return cachedRules;
  } catch {
    cachedRules = {};
    cachedApartmentTypes = null;
    return cachedRules;
  }
}

ğŸ”§ PATCH 3 â€” validatore principale

Sostituire completamente la funzione:

export function canCleanerHandleTaskSync(...)


con:

export function canCleanerHandleTaskSync(
  cleanerRole: string,
  task: any,
  rules: TaskTypesByCleaner | null,
  canDoStraordinaria: boolean = false
): boolean {
  if (!rules) return true;

  const taskType = determineTaskType(task);
  if (!taskType) return true;

  const roleKey = normalizeCleanerRole(cleanerRole);

  const roleRules = rules[roleKey];
  if (!roleRules) return true;

  // straordinaria -> usa flag personalizzato
  if (taskType === "straordinario_apt") {
    return canDoStraordinaria;
  }

  // regola base task â†’ cleaner
  const allowedByTaskType = roleRules[taskType];
  if (!allowedByTaskType) return false;

  // controllo apartments
  if (!canHandleApartment(cleanerRole, task)) {
    return false;
  }

  return true;
}

ğŸ”µ 2. FRONTEND â€” file timeline-view.tsx (IMPORTANTISSIMO)

TUTTE le chiamate:

canCleanerHandleTaskSync(cleaner.role, task, validationRules)


vanno aggiornate cosÃ¬:

canCleanerHandleTaskSync(
  cleaner.role,
  task,
  validationRules,
  cleaner.can_do_straordinaria ?? false
)


Ci sono 5 punti nel file, te li elenco:

â–ªï¸ A â€” dialog incompatibili
â–ªï¸ B â€” useEffect warnings globali
â–ªï¸ C â€” colorazione card cleaner
â–ªï¸ D â€” flag isIncompatible per task singola
â–ªï¸ E â€” â€œho capitoâ€œ acknowledgement

(in ogni punto sostituire il terzo argomento con 4 argomenti come sopra)

ğŸ”´ 3. BACKEND â€” PYTHON

Tutti gli script usavano la struttura task-centrica.

Adesso invece usiamo:

settings["task_types"][cleaner_role][task_type]

ğŸ”§ PATCH â€” client/public/scripts/task_validation.py

Sostituire:

self.rules = settings.get('task_types', {})
...
taskRules = self.rules.get(task_type, {})
allowed = taskRules.get(role_key)


con:

self.rules = settings.get('task_types', {})
...
roleRules = self.rules.get(role_key, {})
allowed = roleRules.get(task_type)


Ecco il blocco completo corretto:

def can_cleaner_handle_task(self, cleaner_role: str, task_type: str, can_do_straordinaria=False) -> bool:
    role_key = self._normalize_cleaner_role(cleaner_role)

    # straordinaria: flag per-cleaner
    if task_type == "straordinario_apt":
        return bool(can_do_straordinaria)

    role_rules = self.rules.get(role_key, {})
    allowed = role_rules.get(task_type)

    if allowed is None:
        return True

    return bool(allowed)

ğŸ”§ PATCH â€” usare appartamenti in Python

GiÃ  ti avevo predisposto can_cleaner_handle_apartment, resta identico.

Basta assicurarsi che ovunque chiami:

can_cleaner_handle_task(cleaner.role, task_type)


tu ora chiami:

can_cleaner_handle_task(cleaner.role, task_type, cleaner.can_do_straordinaria)


e aggiungi:

if not can_cleaner_handle_apartment(cleaner.role, task.apt_type):
    continue


Questo Ã¨ giÃ  fatto nei patch precedenti, va solo aggiornato il nome della matrice.

ğŸ‰ RISULTATO

Dopo questi patch:

âœ” Il formato JSON Ã¨ esattamente quello che vuoi

"task_types" centrato sui ruoli.

âœ” Il frontend capisce correttamente:

formatore non puÃ² premium

formatore non puÃ² straordinaria

formatore non puÃ² apt F

premium non puÃ² straordinaria se non ha can_do_straordinaria

standard non puÃ² premium

eccâ€¦

âœ” Il backend Python assegna EO/HP/LP usando la stessa matrice
âœ” UI drag-and-drop mostra i warning corretti