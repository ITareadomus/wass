import * as fs from 'fs/promises';
import path from 'path';
import { dailyAssignmentRevisionsService } from './daily-assignment-revisions-service';
import { format } from 'date-fns';
import { toZonedTime } from 'date-fns-tz';

/**
 * Workspace Files Helper
 * 
 * Centralizes read/write operations for timeline.json, containers.json, and selected_cleaners.json
 * Storage: MySQL (primary) + filesystem (cache for Python scripts)
 * 
 * Read strategy: Try MySQL first, fallback to filesystem
 * Write strategy: Write to MySQL AND filesystem (dual write for Python script compatibility)
 */

const PATHS = {
  timeline: path.join(process.cwd(), 'client/public/data/output/timeline.json'),
  containers: path.join(process.cwd(), 'client/public/data/output/containers.json'),
  selectedCleaners: path.join(process.cwd(), 'client/public/data/cleaners/selected_cleaners.json'),
};

const TIMEZONE = 'Europe/Rome';

// Helper per ottenere timestamp nel timezone di Roma
function getRomeTimestamp(): string {
  const now = new Date();
  const romeTime = toZonedTime(now, TIMEZONE);
  return format(romeTime, "yyyy-MM-dd HH:mm:ss");
}


/**
 * Atomically write JSON to file using tmp + rename pattern
 */
async function atomicWriteJson(filePath: string, data: any): Promise<void> {
  const tmpPath = `${filePath}.tmp`;
  await fs.writeFile(tmpPath, JSON.stringify(data, null, 2), 'utf-8');
  await fs.rename(tmpPath, filePath);
}

/**
 * Load timeline for a specific work date
 * Priority: MySQL → filesystem → null
 */
export async function loadTimeline(workDate: string): Promise<any | null> {
  try {
    // Try MySQL first
    const rev = await dailyAssignmentRevisionsService.getLatestRevision(workDate);
    if (rev?.timeline) {
      console.log(`✅ Timeline loaded from MySQL for ${workDate} (revision ${rev.revision})`);
      // Sync to filesystem for Python scripts
      await atomicWriteJson(PATHS.timeline, rev.timeline);
      return rev.timeline;
    }
  } catch (err) {
    console.error(`Error loading timeline from MySQL:`, err);
  }

  // Fallback to filesystem (first-time or migration)
  try {
    const data = await fs.readFile(PATHS.timeline, 'utf-8');
    const parsed = JSON.parse(data);

    if (parsed.metadata?.date === workDate || parsed.cleaners_assignments) {
      console.log(`✅ Timeline loaded from filesystem for ${workDate}`);
      return parsed;
    }
  } catch (err) {
    // Filesystem read failed
  }

  console.log(`ℹ️ No timeline found for ${workDate}`);
  return null;
}

/**
 * Save timeline for a specific work date
 * Writes to MySQL AND filesystem
 */
export async function saveTimeline(workDate: string, data: any): Promise<boolean> {
  try {
    // Ensure metadata contains the correct date
    data.metadata = data.metadata || {};
    data.metadata.date = workDate;
    data.metadata.last_updated = getRomeTimestamp();

    // Write to filesystem (for Python scripts compatibility)
    await atomicWriteJson(PATHS.timeline, data);
    console.log(`✅ Timeline saved to filesystem for ${workDate}`);

    // Get current selected_cleaners and create new revision in MySQL
    const selected = await loadSelectedCleanersFromFile(workDate);
    await dailyAssignmentRevisionsService.createRevision(workDate, data, selected?.cleaners || []);
    console.log(`✅ Timeline revision created in MySQL for ${workDate}`);

    return true;
  } catch (err) {
    console.error(`Error saving timeline for ${workDate}:`, err);
    return false;
  }
}

/**
 * Load containers.json for a specific work date
 * Containers are NOT saved to MySQL (regenerated from create_containers.py)
 */
export async function loadContainers(workDate: string): Promise<any | null> {
  try {
    const data = await fs.readFile(PATHS.containers, 'utf-8');
    const parsed = JSON.parse(data);

    if (parsed.containers) {
      console.log(`✅ Containers loaded from filesystem for ${workDate}`);
      return parsed;
    }
  } catch (err) {
    // Filesystem read failed
  }

  console.log(`ℹ️ No containers found for ${workDate}`);
  return null;
}

/**
 * Save containers.json for a specific work date
 * Containers are only saved to filesystem (regenerated by Python scripts)
 */
export async function saveContainers(workDate: string, data: any): Promise<boolean> {
  try {
    await atomicWriteJson(PATHS.containers, data);
    console.log(`✅ Containers saved to filesystem for ${workDate}`);
    return true;
  } catch (err) {
    console.error(`Error saving containers for ${workDate}:`, err);
    return false;
  }
}

/**
 * Load selected_cleaners from filesystem only (helper)
 */
async function loadSelectedCleanersFromFile(workDate: string): Promise<any | null> {
  try {
    const data = await fs.readFile(PATHS.selectedCleaners, 'utf-8');
    return JSON.parse(data);
  } catch (err) {
    return null;
  }
}

/**
 * Load selected_cleaners for a specific work date
 * Priority: MySQL → filesystem → null
 */
export async function loadSelectedCleaners(workDate: string): Promise<any | null> {
  try {
    // Try MySQL first
    const rev = await dailyAssignmentRevisionsService.getLatestRevision(workDate);
    if (rev?.selected_cleaners) {
      const scData = {
        cleaners: Array.isArray(rev.selected_cleaners) ? rev.selected_cleaners : [],
        total_selected: Array.isArray(rev.selected_cleaners) ? rev.selected_cleaners.length : 0,
        metadata: { date: workDate, loaded_at: getRomeTimestamp() }
      };
      console.log(`✅ Selected cleaners loaded from MySQL for ${workDate} (revision ${rev.revision})`);
      // Sync to filesystem
      await atomicWriteJson(PATHS.selectedCleaners, scData);
      return scData;
    }
  } catch (err) {
    console.error(`Error loading selected cleaners from MySQL:`, err);
  }

  // Fallback to filesystem
  try {
    const data = await fs.readFile(PATHS.selectedCleaners, 'utf-8');
    const parsed = JSON.parse(data);

    if (!parsed.metadata?.date || parsed.metadata.date === workDate) {
      console.log(`✅ Selected cleaners loaded from filesystem for ${workDate}`);
      return parsed;
    }
  } catch (err) {
    // Filesystem read failed
  }

  console.log(`ℹ️ No selected cleaners found for ${workDate}`);
  return null;
}

/**
 * Save selected_cleaners for a specific work date
 * Writes to MySQL AND filesystem
 */
export async function saveSelectedCleaners(workDate: string, data: any): Promise<boolean> {
  try {
    // Ensure metadata contains the correct date
    data.metadata = data.metadata || {};
    data.metadata.date = workDate;
    data.metadata.last_updated = getRomeTimestamp();

    // Write to filesystem
    await atomicWriteJson(PATHS.selectedCleaners, data);
    console.log(`✅ Selected cleaners saved to filesystem for ${workDate}`);

    // Get current timeline and create new revision in MySQL
    let timeline = null;
    try {
      const timelineData = await fs.readFile(PATHS.timeline, 'utf-8');
      timeline = JSON.parse(timelineData);
    } catch (err) {
      timeline = {};
    }

    const cleanersArray = data.cleaners || [];
    await dailyAssignmentRevisionsService.createRevision(workDate, timeline, cleanersArray);
    console.log(`✅ Selected cleaners revision created in MySQL for ${workDate}`);

    return true;
  } catch (err) {
    console.error(`Error saving selected cleaners for ${workDate}:`, err);
    return false;
  }
}

/**
 * Reset timeline: svuota assegnazioni ma preserva selected_cleaners
 */
export async function resetTimeline(workDate: string): Promise<boolean> {
  try {
    const emptyTimeline = {
      metadata: {
        date: workDate,
        last_updated: getRomeTimestamp(),
        created_by: 'reset'
      },
      cleaners_assignments: [],
      meta: {
        total_cleaners: 0,
        used_cleaners: 0,
        assigned_tasks: 0
      }
    };

    // Write empty timeline to filesystem
    await atomicWriteJson(PATHS.timeline, emptyTimeline);
    console.log(`✅ Timeline reset to empty for ${workDate}`);

    // Create new revision in MySQL with empty timeline but preserving selected_cleaners
    const selected = await loadSelectedCleanersFromFile(workDate);
    await dailyAssignmentRevisionsService.createRevision(workDate, emptyTimeline, selected?.cleaners || []);
    console.log(`✅ Timeline reset revision created in MySQL for ${workDate}`);

    return true;
  } catch (err) {
    console.error(`Error resetting timeline for ${workDate}:`, err);
    return false;
  }
}

/**
 * Get raw file paths (for backward compatibility)
 */
export function getFilePaths() {
  return { ...PATHS };
}