import * as fs from 'fs/promises';
import path from 'path';
import { storageService } from './storage-service';

/**
 * Workspace Files Helper
 * 
 * Centralizes read/write operations for timeline.json, containers.json, and selected_cleaners.json
 * 
 * Storage architecture:
 * - Filesystem: Used for local dev and Python scripts compatibility
 * - Object Storage: Single file DD-MM-YYYY/assignments_data.json containing { selected_cleaners, timeline }
 * 
 * Every save writes to BOTH filesystem AND Object Storage synchronously.
 */

const PATHS = {
  timeline: path.join(process.cwd(), 'client/public/data/output/timeline.json'),
  containers: path.join(process.cwd(), 'client/public/data/output/containers.json'),
  selectedCleaners: path.join(process.cwd(), 'client/public/data/cleaners/selected_cleaners.json'),
};

/**
 * Atomically write JSON to file using tmp + rename pattern
 */
async function atomicWriteJson(filePath: string, data: any): Promise<void> {
  const tmpPath = `${filePath}.tmp`;
  await fs.writeFile(tmpPath, JSON.stringify(data, null, 2), 'utf-8');
  await fs.rename(tmpPath, filePath);
}

/**
 * Load timeline.json for a specific work date
 * Priority: Object Storage → filesystem fallback
 */
export async function loadTimeline(workDate: string): Promise<any | null> {
  // First try Object Storage (source of truth)
  try {
    const timeline = await storageService.getTimeline(workDate);
    if (timeline) {
      // Write to filesystem for Python scripts compatibility
      await atomicWriteJson(PATHS.timeline, timeline);
      return timeline;
    }
  } catch (err) {
    console.error(`Error loading timeline from Object Storage:`, err);
  }

  // Fallback to filesystem if date matches
  try {
    const data = await fs.readFile(PATHS.timeline, 'utf-8');
    const parsed = JSON.parse(data);
    if (parsed.metadata?.date === workDate) {
      console.log(`✅ Timeline loaded from filesystem for ${workDate}`);
      return parsed;
    }
  } catch (err) {
    // File doesn't exist
  }

  console.log(`ℹ️ No timeline found for ${workDate}`);
  return null;
}

/**
 * Save timeline.json for a specific work date
 * Writes to filesystem AND Object Storage synchronously
 */
export async function saveTimeline(workDate: string, data: any): Promise<boolean> {
  try {
    // Ensure metadata contains the correct date
    data.metadata = data.metadata || {};
    data.metadata.date = workDate;
    data.metadata.last_updated = new Date().toISOString();

    // Write to filesystem (for Python scripts)
    await atomicWriteJson(PATHS.timeline, data);
    console.log(`✅ Timeline saved to filesystem for ${workDate}`);

    // Write to Object Storage (synchronously - wait for completion)
    const success = await storageService.saveTimeline(workDate, data);
    if (!success) {
      console.warn(`⚠️ Failed to persist timeline to Object Storage for ${workDate}`);
    }

    return true;
  } catch (err) {
    console.error(`Error saving timeline for ${workDate}:`, err);
    return false;
  }
}

/**
 * Load containers.json for a specific work date
 * Containers are local only (regenerated by Python scripts)
 */
export async function loadContainers(workDate: string): Promise<any | null> {
  try {
    const data = await fs.readFile(PATHS.containers, 'utf-8');
    const parsed = JSON.parse(data);
    if (parsed.containers) {
      console.log(`✅ Containers loaded from filesystem for ${workDate}`);
      return parsed;
    }
  } catch (err) {
    // File doesn't exist
  }

  console.log(`ℹ️ No containers found for ${workDate}`);
  return null;
}

/**
 * Save containers.json for a specific work date
 * Containers are local only (not persisted to Object Storage)
 */
export async function saveContainers(workDate: string, data: any): Promise<boolean> {
  try {
    await atomicWriteJson(PATHS.containers, data);
    console.log(`✅ Containers saved to filesystem for ${workDate}`);
    return true;
  } catch (err) {
    console.error(`Error saving containers for ${workDate}:`, err);
    return false;
  }
}

/**
 * Load selected_cleaners.json for a specific work date
 * Priority: Object Storage → filesystem fallback
 */
export async function loadSelectedCleaners(workDate: string): Promise<any | null> {
  // First try Object Storage (source of truth)
  try {
    const cleaners = await storageService.getSelectedCleaners(workDate);
    if (cleaners && cleaners.length > 0) {
      console.log(`✅ Selected cleaners loaded from Object Storage for ${workDate}`);
      // Create structure expected by frontend
      const data = {
        metadata: { date: workDate, last_updated: new Date().toISOString() },
        cleaners: cleaners
      };
      // Write to filesystem for Python scripts compatibility
      await atomicWriteJson(PATHS.selectedCleaners, data);
      return data;
    }
  } catch (err) {
    console.error(`Error loading selected cleaners from Object Storage:`, err);
  }

  // Fallback to filesystem
  try {
    const data = await fs.readFile(PATHS.selectedCleaners, 'utf-8');
    const parsed = JSON.parse(data);
    if (!parsed.metadata?.date || parsed.metadata.date === workDate) {
      console.log(`✅ Selected cleaners loaded from filesystem for ${workDate}`);
      return parsed;
    }
  } catch (err) {
    // File doesn't exist
  }

  console.log(`ℹ️ No selected cleaners found for ${workDate}`);
  return null;
}

/**
 * Save selected_cleaners.json for a specific work date
 * Writes to filesystem AND Object Storage synchronously
 */
export async function saveSelectedCleaners(workDate: string, data: any): Promise<boolean> {
  try {
    // Ensure metadata contains the correct date
    data.metadata = data.metadata || {};
    data.metadata.date = workDate;
    data.metadata.last_updated = new Date().toISOString();

    // Write to filesystem (for Python scripts)
    await atomicWriteJson(PATHS.selectedCleaners, data);
    console.log(`✅ Selected cleaners saved to filesystem for ${workDate}`);

    // Extract cleaners array and save to Object Storage (synchronously)
    const cleanersArray = data.cleaners || data.selected_cleaners || [];
    const success = await storageService.saveSelectedCleaners(workDate, cleanersArray);
    if (!success) {
      console.warn(`⚠️ Failed to persist selected cleaners to Object Storage for ${workDate}`);
    }

    return true;
  } catch (err) {
    console.error(`Error saving selected cleaners for ${workDate}:`, err);
    return false;
  }
}

/**
 * Reset timeline for a specific date (clear assignments, keep selected_cleaners)
 */
export async function resetTimeline(workDate: string): Promise<boolean> {
  const emptyTimeline = {
    metadata: {
      last_updated: new Date().toISOString(),
      date: workDate,
      created_by: 'system'
    },
    cleaners_assignments: [],
    meta: {
      total_cleaners: 0,
      used_cleaners: 0,
      assigned_tasks: 0
    }
  };

  // Save to filesystem
  await atomicWriteJson(PATHS.timeline, emptyTimeline);
  
  // Reset on Object Storage (preserves selected_cleaners)
  return storageService.resetTimeline(workDate);
}

/**
 * Check if saved assignments exist for a date
 */
export async function hasAssignments(workDate: string): Promise<boolean> {
  return storageService.hasAssignments(workDate);
}

/**
 * Get raw file paths (for backward compatibility with existing code)
 */
export function getFilePaths() {
  return { ...PATHS };
}
